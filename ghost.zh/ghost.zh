// ghost.zh
// Version 2.3.2

// See ghost.txt for documentation.

// Standard settings -----------------------------------------------------------

// Shadow settings
const int GH_SHADOW_TILE = 27401;
const int GH_SHADOW_CSET = 7;
const int GH_SHADOW_TRANSLUCENT = 0; // 0 = No, 1 = Yes
const int GH_SHADOW_FLICKER = 0; // 0 = No, 1 = Yes

// AutoGhost settings
const int AUTOGHOST_MIN_FFC = 1; // Min: 1, Max: 32
const int AUTOGHOST_MAX_FFC = 32; // Min: 1, Max: 32
const int AUTOGHOST_MIN_ENEMY_ID = 20; // Min: 20, Max: 511
const int AUTOGHOST_MAX_ENEMY_ID = 511; // Min: 20, Max: 511

// Other settings
const int GH_DRAW_OVER_THRESHOLD = 32;
const float GH_GRAVITY = 0.16;
const float GH_TERMINAL_VELOCITY = 3.2;
const int GH_SPAWN_SPRITE = 22; // Min: 0, Max: 255, Default: 22
const int GH_FAKE_Z = 0; // 0 = No, 1 = Yes
const int GH_ENEMIES_FLICKER = 0; // 0 = No, 1 = Yes

// Top-left corner of a 4x4 block of blank tiles
const int GH_BLANK_TILE = 65456; // Min: 0, Max: 65456

// Invisible combo with no properties set
const int GH_INVISIBLE_COMBO = 1; // Min: 1, Max: 65279

// End standard settings -------------------------------------------------------


// Advanced settings -----------------------------------------------------------

// Misc. Attribute 11 can be set to this instead of GH_INVISIBLE_COMBO
const int __GH_INVISIBLE_ALT = -1;

// This will use the invisible combo, but also set npc->Extend to 3
const int __GH_INVISIBLE_EXTEND = -2;

// If enabled, the FFC will be invisible, and Screen->DrawCombo will be used
// to display the enemy.
const int __GH_USE_DRAWCOMBO = 1;

// npc->Misc[] index
// Set this so it doesn't conflict with other scripts. Legal values are 0-15.
const int __GHI_IN_USE = 15;

// eweapon->Misc[] indices
// These must be unique numbers between 0 and 15.
const int __EWI_DUMMY_SOUND  = 1; // Only used by dummies
const int __EWI_DUMMY_STEP   = 2; // Only used by dummies
const int __EWI_DUMMY_SPRITE = 3; // Only used by dummies
const int __EWI_ID           = 4;
const int __EWI_XPOS         = 5;
const int __EWI_YPOS         = 6;
const int __EWI_WORK         = 7;
const int __EWI_WORK_2       = 8; // Only used by a few movement types
const int __EWI_MOVEMENT     = 9;
const int __EWI_MOVEMENT_ARG = 10;
const int __EWI_LIFESPAN     = 11;
const int __EWI_LIFESPAN_ARG = 12;
const int __EWI_ON_DEATH     = 13;
const int __EWI_ON_DEATH_ARG = 14;
const int __EWI_FLAGS        = 15; // Every index but this one can be used by non-ghost.zh EWeapons

// End advanced settings -------------------------------------------------------



// Enemy flags
// Old flags - 16 bits, can be ORed together
const int GHF_KNOCKBACK          = 0000000000000001b;
const int GHF_KNOCKBACK_4WAY     = 0000000000000011b;
const int GHF_REDUCED_KNOCKBACK  = 0000000000000101b;
const int GHF_STUN               = 0000000000001000b;
const int GHF_CLOCK              = 0000000000010000b;
const int GHF_NO_FALL            = 0000000000100000b;
const int GHF_SET_DIRECTION      = 0000000001000000b;
const int GHF_SET_OVERLAY        = 0000000010000000b;
const int GHF_4WAY               = 0000000100000000b;
const int GHF_8WAY               = 0000001000000000b;
const int GHF_IGNORE_SOLIDITY    = 0000010000000000b;
const int GHF_IGNORE_WATER       = 0000100000000000b;
const int GHF_IGNORE_PITS        = 0001000000000000b;
const int GHF_MOVE_OFFSCREEN     = 0010000000000000b;
const int GHF_FAKE_Z             = 0100000000000000b;
const int GHF_FULL_TILE_MOVEMENT = 1000000000000000b;

// Combined old flags
const int GHF_NORMAL             = 0000000001011001b;
const int GHF_IGNORE_ALL_TERRAIN = 0001110000000000b;

// New flags - Set individually, identified as new by 17th bit
const int GHF_FLYING_ENEMY    = 0x10000;
const int GHF_IGNORE_NO_ENEMY = 0x10001;
const int GHF_WATER_ONLY      = 0x10002;
const int GHF_DEEP_WATER_ONLY = 0x10003;

// Internal enemy flags
const int __GHFI_GOT_HIT               = 0000001b;
const int __GHFI_DIR_FORCED            = 0000010b;
const int __GHFI_CSET_FORCED           = 0000100b;
const int __GHFI_SHADOW_FLICKER        = 0001000b;
const int __GHFI_KNOCKBACK_INTERRUPTED = 0010000b;
const int __GHFI_HIT_LINK              = 0100000b;
const int __GHFI_FLICKER               = 1000000b;
const int __GH_UNSET_FLAGS             = 0101000b; // Used to unset flags that last one frame

// Arguments to SetEWeaponMovement()
const int EWM_SINE_WAVE         = 1;
const int EWM_SINE_WAVE_FAST    = 2;
const int EWM_HOMING            = 3;
const int EWM_HOMING_REAIM      = 4;
const int EWM_RANDOM            = 5;
const int EWM_RANDOM_REAIM      = 6;
const int EWM_VEER              = 7;
const int EWM_THROW             = 15;
const int EWM_THROW_STOP        = 16;
const int EWM_THROW_BOUNCE      = 17;
const int EWM_THROW_BOUNCE_STOP = 18;
const int EWM_FALL              = 19;
const int EWM_DRIFT             = 20;
const int EWM_DRIFT_WAIT        = 28;

// Alternate arguments for movements with direction options
const int EWM_VEER_UP              = 7;
const int EWM_VEER_DOWN            = 8;
const int EWM_VEER_LEFT            = 9;
const int EWM_VEER_RIGHT           = 10;
const int EWM_VEER_LEFTUP          = 11;
const int EWM_VEER_RIGHTUP         = 12;
const int EWM_VEER_LEFTDOWN        = 13;
const int EWM_VEER_RIGHTDOWN       = 14;
const int EWM_DRIFT_UP             = 20;
const int EWM_DRIFT_DOWN           = 21;
const int EWM_DRIFT_LEFT           = 22;
const int EWM_DRIFT_RIGHT          = 23;
const int EWM_DRIFT_LEFTUP         = 24;
const int EWM_DRIFT_RIGHTUP        = 25;
const int EWM_DRIFT_LEFTDOWN       = 26;
const int EWM_DRIFT_RIGHTDOWN      = 27;
const int EWM_DRIFT_WAIT_UP        = 28;
const int EWM_DRIFT_WAIT_DOWN      = 29;
const int EWM_DRIFT_WAIT_LEFT      = 30;
const int EWM_DRIFT_WAIT_RIGHT     = 31;
const int EWM_DRIFT_WAIT_LEFTUP    = 32;
const int EWM_DRIFT_WAIT_RIGHTUP   = 33;
const int EWM_DRIFT_WAIT_LEFTDOWN  = 34;
const int EWM_DRIFT_WAIT_RIGHTDOWN = 35;

// Arguments to SetEWeaponLifespan()
const int EWL_TIMER        = 1;
const int EWL_NEAR_LINK    = 2;
const int EWL_SLOW_TO_HALT = 3;

// Arguments to SetEWeaponDeathEffect()
const int EWD_VANISH             = 1;
const int EWD_AIM_AT_LINK        = 2;
const int EWD_EXPLODE            = 3;
const int EWD_SBOMB_EXPLODE      = 4;
const int EWD_4_FIREBALLS_HV     = 5;
const int EWD_4_FIREBALLS_DIAG   = 6;
const int EWD_4_FIREBALLS_RANDOM = 7;
const int EWD_8_FIREBALLS        = 8;
const int EWD_4_FIRES_HV         = 9;
const int EWD_4_FIRES_DIAG       = 10;
const int EWD_4_FIRES_RANDOM     = 11;
const int EWD_8_FIRES            = 12;
const int EWD_SPAWN_NPC          = 13;
const int EWD_FIRE               = 14;
const int EWD_RUN_SCRIPT         = 15;

// Prototype-based version
const int EWD_EVEN   = 1;
const int EWD_RANDOM = 2;
const int EWD_AIMED  = 3;

// EWeapon flags
const int EWF_UNBLOCKABLE    = 0000000001b;
const int EWF_ROTATE         = 0000000010b;
const int EWF_SHADOW         = 0000000100b;
const int EWF_FLICKER        = 0000001000b;
const int EWF_NO_COLLISION   = 0000010000b;

// Internal EWeapon flags
const int __EWFI_DEAD              = 0000100000b;
const int __EWFI_SHADOW_FLICKER    = 0001000000b;
const int __EWFI_DUMMY             = 0010000000b;
const int __EWFI_IS_GHZH_EWPN      = 0100000000b;
const int __EWFI_DUMMY_CHECK       = 0110000000b;
const int __EWFI_DEATH_EFFECT_DONE = 1000000000b;
const int __EWFI_INTERNAL          = 1111100000b;

// Positions in the attached FFC array
const int GH_FFC_ID          = 0;  // 0, 7, 14...
const int GH_FFC_DATA        = 1;  // 1, 8, 15...
const int GH_FFC_X           = 2;  // 2, 9, 16...
const int GH_FFC_Y           = 3;  // 3, 10, 17...
const int GH_FFC_TILE_WIDTH  = 4;  // 4, 11, 18...
const int GH_FFC_TILE_HEIGHT = 5;  // 5, 12, 19...
const int GH_FFC_FLAGS       = 6;  // 6, 13, 20...

// Attached FFC combo types
const int GH_FFCF_FIXED_DATA    = 001b;
const int GH_FFCF_NO_FLASH      = 010b;
const int GH_FFCF_HIDDEN        = 100b;

// Total number of array elements used per FFC
const int __GH_FFC_SIZE = 7;

// Global variables

// Position
float Ghost_X;
float Ghost_Y;
float Ghost_Z;
int Ghost_Dir;

// Velocity and acceleration
float Ghost_Jump;
float Ghost_Vx;
float Ghost_Vy;
float Ghost_Ax;
float Ghost_Ay;

// Appearance
int Ghost_Data;
int Ghost_CSet;
int Ghost_TileWidth;
int Ghost_TileHeight;

// HP
int Ghost_HP;

// Internal use
int __Ghost_Flags;
int __Ghost_Flags2;
int __Ghost_InternalFlags;
float __Ghost_PrevX;
float __Ghost_PrevY;
int __Ghost_FlashCounter;
int __Ghost_KnockbackCounter;
int __Ghost_XOffsets;
int __Ghost_YOffsets;
int __Ghost_Scripts[32];
int __Ghost_AttachedFFCs;

// These are needed for clocks to work
int __ghzhPrevScreen;
int __ghzhClockTimer;


// =================
// |||| SCRIPTS ||||
// =================

global script GhostZHActiveScript
{
    void run()
    {
        StartClock();

        while(true)
        {
            UpdateEWeapons();
            UpdateClock();
            CleanUpGhostFFCs();

            Waitdraw();
            AutoGhost();

            Waitframe();
        }
    }
}

item script GhostZHClockScript
{
    void run(int duration)
    {
        if(duration<=0)
            __ghzhClockTimer=-1;
        else
            __ghzhClockTimer=duration;
    }
}


// ========================
// |||| INITIALIZATION ||||
// ========================

void Ghost_Init(ffc this, npc ghost)
{
    __Ghost_InitInternal(this, ghost, false, this->Data, this->CSet);
}

npc Ghost_InitCreate(ffc this, int enemyID)
{
    npc ghost=Screen->CreateNPC(enemyID);
    __Ghost_InitInternal(this, ghost, false, this->Data, this->CSet);
    return ghost;
}

npc Ghost_InitWait(ffc this, int enemyIndex, bool useEnemyPos)
{
    int combo=this->Data;
    this->Data=GH_INVISIBLE_COMBO;
    
    // Wait until there are enough enemies
    for(int i=0; i<4; i++)
    {
        if(Screen->NumNPCs()>=enemyIndex)
        {
            npc ghost=Screen->LoadNPC(enemyIndex);
            __Ghost_InitInternal(this, ghost, useEnemyPos, combo, this->CSet);
            return ghost;
        }
        Waitframe();
    }

    // Didn't find the enemy, so quit
    this->Data=0;
    Quit();
}

npc Ghost_InitWait2(ffc this, int enemyID, bool useEnemyPos)
{
    int combo=this->Data;
    npc ghost;
    this->Data=GH_INVISIBLE_COMBO;
    
    for(int i=0; i<4; i++)
    {
        // Find the right enemy
        for(int j=1; j<=Screen->NumNPCs(); j++)
        {
            ghost=Screen->LoadNPC(j);
            
            // Wrong ID or already in use
            if(ghost->ID!=enemyID)
                continue;
            if(ghost->Misc[__GHI_IN_USE]!=0)
                continue;

            __Ghost_InitInternal(this, ghost, useEnemyPos, combo, this->CSet);
            return ghost;
        }
        Waitframe();
    }

    // Didn't find the enemy, so quit
    this->Data=0;
    Quit();
}

npc Ghost_InitSpawn(ffc this, int enemyID)
{
    npc ghost=SpawnNPC(enemyID);
    __Ghost_InitInternal(this, ghost, false, this->Data, this->CSet);
}

npc Ghost_InitAutoGhost(ffc this, int enemyID)
{
    npc ghost;
    
    // Find the right enemy
    for(int i=1; i<=Screen->NumNPCs(); i++)
    {
        ghost=Screen->LoadNPC(i);
        
        // Wrong ID or already in use
        if(ghost->ID!=enemyID)
            continue;
        if(ghost->Misc[__GHI_IN_USE]!=0)
            continue;
        
        __Ghost_InitInternal(this, ghost, true, ghost->Attributes[10], ghost->CSet);
        
        if((ghost->MiscFlags&100000000b)!=0) // That's "Is Transparent"
            this->Flags[FFCF_TRANS]=true;
        return ghost;
    }
    
    // No enemy found, so quit. This shouldn't ever happen, so log it.
    int error1[]="ghost.zh: AutoGhost initialization failed - enemy missing.\n";
    int error2[30]="  DMap %d, screen %X\n";
    int error3[30]="  Script %d, enemy ID %d\n";
    printf(error1);
    printf(error2, Game->GetCurDMap(), Game->GetCurDMapScreen());
    printf(error3, this->Script, enemyID);
    
    this->Data=0;
    Quit();
}


// ===============
// |||| FLAGS ||||
// ===============

void Ghost_SetFlag(int flag)
{
    if((flag&0x10000)!=0)
    {
        // New style flag - get the index (the last 16 bits)
        // and set that bit in __Ghost_Flags2
        __Ghost_Flags2|=1<<(flag&0xFFFF);
    }
    else
    {
        // Old style flag - just OR it into __Ghost_Flags
        __Ghost_Flags|=flag;
    }
}

void Ghost_UnsetFlag(int flag)
{
    if((flag&0x10000)!=0)
    {
        // New style flag
        __Ghost_Flags2&=~1<<(flag&0xFFFF);
    }
    else
    {
        // Old style flag
        __Ghost_Flags&=~flag;
    }
}

bool Ghost_FlagIsSet(int flag)
{
    if((flag&0x10000)!=0)
    {
        // New style flag
        return (__Ghost_Flags2&(1<<(flag&0xFFFF)))!=0;
    }
    else
    {
        // Old style flag
        return (__Ghost_Flags&flag)==flag;
    }
}

void Ghost_ClearFlags()
{
    __Ghost_Flags=0;
    __Ghost_Flags2=0;
}


// ================
// |||| UPDATE ||||
// ================

bool Ghost_Waitframe(ffc this, npc ghost, bool clearOnDeath, bool quitOnDeath)
{
    // Handle gravity first
    ghost->Jump=0;
    if(!Ghost_FlagIsSet(GHF_NO_FALL))
    {
        // Sideview: Jump/fall on Y axis
        if(IsSideview())
        {
            // Use Ghost_CanMove to check for platforms
            if(Ghost_Jump!=0 || Ghost_CanMove(DIR_DOWN, 1, 2))
            {
                // Temporarily unset GHF_SET_DIRECTION so that Ghost_Move doesn't
                // change the enemy's direction here
                bool setDir=Ghost_FlagIsSet(GHF_SET_DIRECTION);
                Ghost_UnsetFlag(GHF_SET_DIRECTION);
                
                // Jumping
                if(Ghost_Jump>0)
                {
                    // Set GHF_NO_FALL temporarily so Ghost_CanMove(DIR_UP) can return true
                    Ghost_SetFlag(GHF_NO_FALL);
                    
                    Ghost_Move(DIR_UP, Ghost_Jump, 2);
                    Ghost_Jump=Max(Ghost_Jump-GH_GRAVITY, -GH_TERMINAL_VELOCITY);
                    
                    // If it's still jumping, check if it can move any farther;
                    // if it can't, it's hit something and should start falling
                    if(Ghost_Jump>0 && !Ghost_CanMove(DIR_UP, 1, 2))
                        Ghost_Jump=0;
                    
                    Ghost_UnsetFlag(GHF_NO_FALL);
                }
                // Falling
                else
                {
                    Ghost_Move(DIR_DOWN, -Ghost_Jump, 2);
                    
                    // Can it fall farther?
                    if(Ghost_CanMove(DIR_DOWN, 1, 2))
                        Ghost_Jump=Max(Ghost_Jump-GH_GRAVITY, -GH_TERMINAL_VELOCITY);
                    // If not, stop falling
                    else
                        Ghost_Jump=0;
                }
                
                // Restore the flag
                if(setDir)
                    Ghost_SetFlag(GHF_SET_DIRECTION);
            }
        }
        // Top-down: Jump/fall on Z axis
        else
        {
            if(Ghost_Jump!=0 || Ghost_Z>0)
            {
                if(Ghost_Z+Ghost_Jump<=0)
                {
                    Ghost_Z=0;
                    Ghost_Jump=0;
                }
                else
                {
                    Ghost_Z+=Ghost_Jump;
                    Ghost_Jump=Max(Ghost_Jump-GH_GRAVITY, -GH_TERMINAL_VELOCITY);
                }
            }
        }
    }

    // Then velocity and acceleration
    if(Ghost_Vx!=0 || Ghost_Vy!=0 || Ghost_Ax!=0 || Ghost_Ay!=0)
    {
        Ghost_Vx+=Ghost_Ax;
        Ghost_Vy+=Ghost_Ay;

        Ghost_MoveXY(Ghost_Vx, Ghost_Vy, 2);
        Ghost_ForceDir(Ghost_Dir);
    }

    Ghost_SetPosition(this, ghost);

    __Ghost_WaitframePart1(this, ghost, false);
    __Ghost_UpdateFlashing(this, ghost);
    Ghost_WaitframeLight(this, ghost);
    __Ghost_InternalFlags&=__GH_UNSET_FLAGS;
    return __Ghost_WaitframePart2(this, ghost, clearOnDeath, quitOnDeath);
}

bool Ghost_Waitframe2(ffc this, npc ghost, bool clearOnDeath, bool quitOnDeath)
{
    Ghost_X=ghost->X;
    Ghost_Y=ghost->Y;
    Ghost_Z=ghost->Z;
    Ghost_Jump=ghost->Jump;
    
    this->X=VBound(Ghost_X+ghost->DrawXOffset, 256, -64);
    this->Y=VBound(Ghost_Y-Ghost_Z+ghost->DrawYOffset-ghost->DrawZOffset, 176, -64);
    
    __Ghost_WaitframePart1(this, ghost, true);
    __Ghost_UpdateFlashing(this, ghost);
    Ghost_WaitframeLight(this, ghost);
    __Ghost_InternalFlags&=__GH_UNSET_FLAGS;
    
    if(ghost->isValid())
    {
        Ghost_X=ghost->X;
        Ghost_Y=ghost->Y;
        Ghost_Z=ghost->Z;
    }
    
    return __Ghost_WaitframePart2(this, ghost, clearOnDeath, quitOnDeath);
}

void Ghost_WaitframeLight(ffc this, npc ghost)
{
    // Remember all the global variables
    float tempGhostX=Ghost_X;
    float tempGhostY=Ghost_Y;
    float tempGhostZ=Ghost_Z;
    float tempGhostJump=Ghost_Jump;
    float tempGhostVx=Ghost_Vx;
    float tempGhostVy=Ghost_Vy;
    float tempGhostAx=Ghost_Ax;
    float tempGhostAy=Ghost_Ay;
    float tempGhostPrevX=__Ghost_PrevX;
    float tempGhostPrevY=__Ghost_PrevY;
    int tempGhostCSet=Ghost_CSet;
    int tempGhostDir=Ghost_Dir;
    int tempGhostData=Ghost_Data;
    int tempGhostTileWidth=Ghost_TileWidth;
    int tempGhostTileHeight=Ghost_TileHeight;
    int tempGhostFlags=__Ghost_Flags;
    int tempGhostFlags2=__Ghost_Flags2;
    int tempGhostInternalFlags=__Ghost_InternalFlags;
    int tempGhostFlashCounter=__Ghost_FlashCounter;
    int tempGhostKnockbackCounter=__Ghost_KnockbackCounter;
    int tempGhostHP=Ghost_HP;
    int tempGhostXOffsets=__Ghost_XOffsets;
    int tempGhostYOffsets=__Ghost_YOffsets;
    int tempGhostAttachedFFCs=__Ghost_AttachedFFCs;
    
    // Position attached FFCs, draw combos, make FFCs invisible if flickering.
    // Several factors to account for:
    // - FFC or DrawCombo
    // - Visible or flickering
    // - Other FFCs attached or not
    //   - And their various flags
    
    // If visible (i.e. not flickering)
    //     If DrawCombo is enabled
    //         If FFCs are attached
    //             Set positions
    //             Draw combos
    //         Draw combo
    //         Clear combo
    //         Waitframe
    //         Restore combo
    //     Else (DrawCombo disabled)
    //         If FFCs are attached
    //             Set positions
    //             Set combos
    //         Waitframe
    // Else (flickering)
    //     If FFCs are attached
    //         Set positions
    //         Clear, set, or draw combos
    //     Clear combo
    //     Waitframe
    //     Restore combo
    
    // Not flickering
    if((__Ghost_InternalFlags&__GHFI_FLICKER)==0)
    {
        // Using DrawCombo
        if(__GH_USE_DRAWCOMBO>0)
        {
            int layer;
            int opacity;
            int tempData;
            
            if(this->Flags[FFCF_OVERLAY])
                layer=4;
            else
                layer=2;
            
            if(this->Flags[FFCF_TRANS])
                opacity=64;
            else
                opacity=128;
            
            // Draw attached FFCs
            if(__Ghost_AttachedFFCs>0)
            {
                int cset;
                int data;
                
                for(int i=0; i<SizeOfArray(__Ghost_AttachedFFCs); i+=__GH_FFC_SIZE)
                {
                    // Skip hidden FFCs
                    if((__Ghost_AttachedFFCs[i+GH_FFC_FLAGS]&GH_FFCF_HIDDEN)!=0)
                        continue;
                    
                    // Fixed or relative data
                    if((__Ghost_AttachedFFCs[i+GH_FFC_FLAGS]&GH_FFCF_FIXED_DATA)!=0)
                        data=__Ghost_AttachedFFCs[i+GH_FFC_DATA];
                    else
                        data=Ghost_Data+__Ghost_AttachedFFCs[i+GH_FFC_DATA];
                    
                    // Flash or not
                    if((__Ghost_AttachedFFCs[i+GH_FFC_FLAGS]&GH_FFCF_NO_FLASH)!=0)
                        cset=Ghost_CSet;
                    else
                        cset=this->CSet;
                    
                    Screen->DrawCombo(layer,
                       this->X+__Ghost_AttachedFFCs[i+GH_FFC_X],
                       this->Y+__Ghost_AttachedFFCs[i+GH_FFC_Y],
                       data,
                       __Ghost_AttachedFFCs[i+GH_FFC_TILE_WIDTH],
                       __Ghost_AttachedFFCs[i+GH_FFC_TILE_HEIGHT],
                       cset,
                       16*__Ghost_AttachedFFCs[i+GH_FFC_TILE_WIDTH],
                       16*__Ghost_AttachedFFCs[i+GH_FFC_TILE_HEIGHT],
                       0, 0, 0, 0, 0, true, opacity);
                }
            }
            
            Screen->DrawCombo(layer, this->X, this->Y, this->Data,
               this->TileWidth, this->TileHeight,
               this->CSet, 16*this->TileWidth, 16*this->TileHeight,
               0, 0, 0, 0, 0, true, opacity);
            
            tempData=this->Data;
            this->Data=GH_INVISIBLE_COMBO;
            
            Waitframe();
            
            this->Data=tempData;
        }
        
        // Not using DrawCombo
        else
        {
            // Set up attached FFCs
            if(__Ghost_AttachedFFCs>0)
            {
                ffc f;
                
                for(int i=0; i<SizeOfArray(__Ghost_AttachedFFCs); i+=__GH_FFC_SIZE)
                {
                    f=Screen->LoadFFC(__Ghost_AttachedFFCs[i]);
                    
                    // Hidden FFCs
                    if((__Ghost_AttachedFFCs[i+GH_FFC_FLAGS]&GH_FFCF_HIDDEN)!=0)
                    {
                        f->Data=GH_INVISIBLE_COMBO;
                        continue;
                    }
                    
                    f->X=VBound(this->X+__Ghost_AttachedFFCs[i+GH_FFC_X], 256, -64);
                    f->Y=VBound(this->Y+__Ghost_AttachedFFCs[i+GH_FFC_Y], 176, -64);
                    f->TileWidth=__Ghost_AttachedFFCs[i+GH_FFC_TILE_WIDTH];
                    f->TileHeight=__Ghost_AttachedFFCs[i+GH_FFC_TILE_HEIGHT];
                    
                    if((__Ghost_AttachedFFCs[i+GH_FFC_FLAGS]&GH_FFCF_NO_FLASH)==0)
                        f->CSet=this->CSet;
                    else
                        f->CSet=Ghost_CSet;
                    
                    if((__Ghost_AttachedFFCs[i+GH_FFC_FLAGS]&GH_FFCF_FIXED_DATA)!=0)
                        f->Data=__Ghost_AttachedFFCs[i+GH_FFC_DATA];
                    else
                        f->Data=Ghost_Data+__Ghost_AttachedFFCs[i+GH_FFC_DATA];
                }
            }
            
            Waitframe();
        }
    }
    
    // Flickering
    else
    {
        int tempData;
        
        // Clear or draw attached FFCs
        if(__Ghost_AttachedFFCs>0)
        {
            // DrawCombo enabled
            if(__GH_USE_DRAWCOMBO!=0)
            {
                for(int i=0; i<SizeOfArray(__Ghost_AttachedFFCs); i+=__GH_FFC_SIZE)
                {
                    // Hidden or flickering?
                    if((__Ghost_AttachedFFCs[i+GH_FFC_FLAGS]&GH_FFCF_HIDDEN)!=0 ||
                       (__Ghost_AttachedFFCs[i+GH_FFC_FLAGS]&GH_FFCF_NO_FLASH)==0)
                        continue;
                        
                    int data;
                    int layer;
                    int opacity;
                    
                    if(this->Flags[FFCF_OVERLAY])
                        layer=4;
                    else
                        layer=2;
                    
                    if(this->Flags[FFCF_TRANS])
                        opacity=64;
                    else
                        opacity=128;
                    
                    // Fixed or relative data
                    if((__Ghost_AttachedFFCs[i+GH_FFC_FLAGS]&GH_FFCF_FIXED_DATA)!=0)
                        data=__Ghost_AttachedFFCs[i+GH_FFC_DATA];
                    else
                        data=this->Data+__Ghost_AttachedFFCs[i+GH_FFC_DATA];
                    
                    Screen->DrawCombo(layer,
                       this->X+__Ghost_AttachedFFCs[i+GH_FFC_X],
                       this->Y+__Ghost_AttachedFFCs[i+GH_FFC_Y],
                       data,
                       __Ghost_AttachedFFCs[i+GH_FFC_TILE_WIDTH],
                       __Ghost_AttachedFFCs[i+GH_FFC_TILE_HEIGHT],
                       Ghost_CSet,
                       16*__Ghost_AttachedFFCs[i+GH_FFC_TILE_WIDTH],
                       16*__Ghost_AttachedFFCs[i+GH_FFC_TILE_HEIGHT],
                       0, 0, 0, 0, 0, true, opacity);
                }
            }
            
            // DrawCombo disabled
            else
            {
                ffc f;
                
                for(int i=0; i<SizeOfArray(__Ghost_AttachedFFCs); i+=__GH_FFC_SIZE)
                {
                    f=Screen->LoadFFC(__Ghost_AttachedFFCs[i]);
                    
                    // Hidden or flickering?
                    if((__Ghost_AttachedFFCs[i+GH_FFC_FLAGS]&GH_FFCF_HIDDEN)!=0 ||
                       (__Ghost_AttachedFFCs[i+GH_FFC_FLAGS]&GH_FFCF_NO_FLASH)==0)
                    {
                        f->Data=GH_INVISIBLE_COMBO;
                        continue;
                    }
                    
                    f->X=VBound(this->X+__Ghost_AttachedFFCs[i+GH_FFC_X], 256, -64);
                    f->Y=VBound(this->Y+__Ghost_AttachedFFCs[i+GH_FFC_Y], 176, -64);
                    f->TileWidth=__Ghost_AttachedFFCs[i+GH_FFC_TILE_WIDTH];
                    f->TileHeight=__Ghost_AttachedFFCs[i+GH_FFC_TILE_HEIGHT];
                    f->CSet=Ghost_CSet;
                    
                    if((__Ghost_AttachedFFCs[i+GH_FFC_FLAGS]&GH_FFCF_FIXED_DATA)!=0)
                        f->Data=__Ghost_AttachedFFCs[i+GH_FFC_DATA];
                    else
                        f->Data=Ghost_Data+__Ghost_AttachedFFCs[i+GH_FFC_DATA];
                }
            }
        }
        
        tempData=this->Data;
        this->Data=GH_INVISIBLE_COMBO;
        
        Waitframe();
        
        this->Data=tempData;
    }
    
    // Restore the global variables
    Ghost_X=tempGhostX;
    Ghost_Y=tempGhostY;
    Ghost_Z=tempGhostZ;
    Ghost_Jump=tempGhostJump;
    Ghost_Vx=tempGhostVx;
    Ghost_Vy=tempGhostVy;
    Ghost_Ax=tempGhostAx;
    Ghost_Ay=tempGhostAy;
    __Ghost_PrevX=tempGhostPrevX;
    __Ghost_PrevY=tempGhostPrevY;
    Ghost_CSet=tempGhostCSet;
    Ghost_Dir=tempGhostDir;
    Ghost_Data=tempGhostData;
    Ghost_TileWidth=tempGhostTileWidth;
    Ghost_TileHeight=tempGhostTileHeight;
    __Ghost_Flags=tempGhostFlags;
    __Ghost_Flags2=tempGhostFlags2;
    __Ghost_InternalFlags=tempGhostInternalFlags;
    __Ghost_FlashCounter=tempGhostFlashCounter;
    __Ghost_KnockbackCounter=tempGhostKnockbackCounter;
    Ghost_HP=tempGhostHP;
    __Ghost_XOffsets=tempGhostXOffsets;
    __Ghost_YOffsets=tempGhostYOffsets;
    __Ghost_AttachedFFCs=tempGhostAttachedFFCs;
}

bool Ghost_Waitframes(ffc this, npc ghost, bool clearOnDeath, bool quitOnDeath, int numFrames)
{
    for(; numFrames>0; numFrames--)
    {
        if(!Ghost_Waitframe(this, ghost, clearOnDeath, quitOnDeath))
            return false;
    }
    return true;
}

bool Ghost_Waitframes2(ffc this, npc ghost, bool clearOnDeath, bool quitOnDeath, int numFrames)
{
    for(; numFrames>0; numFrames--)
    {
        if(!Ghost_Waitframe2(this, ghost, clearOnDeath, quitOnDeath))
            return false;
    }
    return true;
}

void Ghost_WaitframesLight(ffc this, npc ghost, int numFrames)
{
    for(; numFrames>0; numFrames--)
        Ghost_WaitframeLight(this, ghost);
}

void Ghost_CheckHit(ffc this, npc ghost)
{
    // Just got hit
    if(ghost->HP<Ghost_HP)
    {
        // Remember HP and start flashing
        __Ghost_InternalFlags|=__GHFI_GOT_HIT;
        Ghost_HP=ghost->HP;
        if(__Ghost_FlashCounter<32)
            __Ghost_FlashCounter=32;
        
        // Set knockback counter (but don't handle it yet)
        if(Ghost_FlagIsSet(GHF_KNOCKBACK))
        {
            int xDiff=Link->X-Ghost_X;
            int yDiff=Link->Y-Ghost_Y;
            
            // The correct way to find the knockback direction would be to check
            // the direction of the weapon, but that's not possible. Instead,
            // Link's position and direction are used.
            
            // If Link is close, use his direction
            if(Abs(xDiff)<(Ghost_TileWidth+1)*16 && Abs(yDiff)<(Ghost_TileHeight+1)*16)
            {
                if((Link->Dir&10b)==(Ghost_Dir&10b) || Ghost_Dir>3 || // Both horizontal or vertical, or enemy diagonal?
                   Ghost_FlagIsSet(GHF_KNOCKBACK_4WAY))
                    __Ghost_KnockbackCounter=Link->Dir<<5|16; // Direction and timer are stored together
            }
            
            // If Link is far, use the direction from him to the enemy
            else
            {
                // Up or down
                if(Abs(xDiff)<Abs(yDiff))
                {
                    if(Ghost_Dir==DIR_UP || Ghost_Dir==DIR_DOWN || Ghost_Dir>3 ||
                       Ghost_FlagIsSet(GHF_KNOCKBACK_4WAY))
                    {
                        if(yDiff>0)
                            __Ghost_KnockbackCounter=(DIR_UP<<5)|16;
                        else
                            __Ghost_KnockbackCounter=(DIR_DOWN<<5)|16;
                    }
                }
                // Left or right
                else
                {
                    if(Ghost_Dir==DIR_LEFT || Ghost_Dir==DIR_RIGHT || Ghost_Dir>3 ||
                       Ghost_FlagIsSet(GHF_KNOCKBACK_4WAY))
                    {
                        if(xDiff>0)
                            __Ghost_KnockbackCounter=(DIR_LEFT<<5)|16;
                        else
                            __Ghost_KnockbackCounter=(DIR_RIGHT<<5)|16;
                    }
                }
            }
        }
    }
    
    // Handle knockback
    if(__Ghost_KnockbackCounter!=0)
    {
        int dir=__Ghost_KnockbackCounter>>5;
        int counter=__Ghost_KnockbackCounter&31;
        int step;
        
        if(Ghost_FlagIsSet(GHF_REDUCED_KNOCKBACK))
            step=2;
        else
            step=4;
        
        // Get knocked back
        if(Ghost_CanMove(dir, step, 2))
        {
            int dX=0;
            int dY=0;
            
            counter--;
            if(counter>0)
                __Ghost_KnockbackCounter=(dir<<5)|counter;
            else
                __Ghost_KnockbackCounter=0;
            
            if(dir==DIR_UP)
                dY=-step;
            else if(dir==DIR_DOWN)
                dY=step;
            else if(dir==DIR_LEFT)
                dX=-step;
            else // Right
                dX=step;
            
            // Adjust all relevant position variables so this isn't mistaken for normal movement
            if(dX!=0)
            {
                Ghost_X+=dX;
                __Ghost_PrevX+=dX;
                Ghost_SetPosition(this, ghost);
            }
            else if(dY!=0)
            {
                Ghost_Y+=dY;
                __Ghost_PrevY+=dY;
                Ghost_SetPosition(this, ghost);
            }
        }
        
        // Can't move any farther; end knockback
        else
        {
            int newX=-1;
            int newY=-1;
            
            __Ghost_KnockbackCounter=0;
            __Ghost_InternalFlags|=__GHFI_KNOCKBACK_INTERRUPTED;
            
            if(dir==DIR_UP)
                newY=Floor(Ghost_Y/8)*8;
            else if(dir==DIR_DOWN)


                newY=Ceiling((Ghost_Y<<0)/8)*8;
            else if(dir==DIR_LEFT)
                newX=Floor(Ghost_X/8)*8;
            else // Right
                newX=Ceiling((Ghost_X<<0)/8)*8;
            
            if(newX!=-1)
            {
                __Ghost_PrevX+=newX-Ghost_X;
                Ghost_X=newX;
                Ghost_SetPosition(this, ghost);
            }
            else if(newY!=-1)
            {
                __Ghost_PrevY+=newY-Ghost_Y;
                Ghost_Y=newY;
                Ghost_SetPosition(this, ghost);
            }
        }
    }
}

bool Ghost_CheckFreeze(ffc this, npc ghost)
{
    if((Ghost_FlagIsSet(GHF_CLOCK) && __ghzhClockTimer!=0) ||
       (Ghost_FlagIsSet(GHF_STUN) && ghost->Stun>0))
    {
        // Stop all movement
        float vx=this->Vx;
        float vy=this->Vy;
        float ax=this->Ax;
        float ay=this->Ay;

        this->Vx=0;
        this->Vy=0;
        this->Ax=0;
        this->Ay=0;

        // Do nothing except get hit until recovered
        while((Ghost_FlagIsSet(GHF_CLOCK) && __ghzhClockTimer!=0) ||
              (Ghost_FlagIsSet(GHF_STUN) && ghost->Stun>0))
        {
            __Ghost_UpdateFlashing(this, ghost);
            Ghost_WaitframeLight(this, ghost);

            if(!ghost->isValid() || ghost->HP<=0)
                return false;

            Ghost_SetPosition(this, ghost);

            if(Ghost_FlagIsSet(GHF_8WAY))
                this->Data=Ghost_Data+VBound(Ghost_Dir, 7, 0);
            else if(Ghost_FlagIsSet(GHF_4WAY))
                this->Data=Ghost_Data+VBound(Ghost_Dir, 3, 0);
            else
                this->Data=Ghost_Data;

            Ghost_CheckHit(this, ghost);
        }

        // Restore movement
        this->Vx=vx;
        this->Vy=vy;
        this->Ax=ax;
        this->Ay=ay;
    }

    return true;
}


// ==================
// |||| MOVEMENT ||||
// ==================

void Ghost_Move(int dir, float step, int imprecision)
{
    float xStep=0;
    float yStep=0;

    if(dir==DIR_UP)
        yStep=-step;
    else if(dir==DIR_DOWN)
        yStep=step;
    else if(dir==DIR_LEFT)
        xStep=-step;
    else if(dir==DIR_RIGHT)
        xStep=step;
    else if(dir==DIR_LEFTUP)
    {
        xStep=-step*0.7071;
        yStep=-step*0.7071;
    }
    else if(dir==DIR_RIGHTUP)
    {
        xStep=step*0.7071;
        yStep=-step*0.7071;
    }
    else if(dir==DIR_LEFTDOWN)
    {
        xStep=-step*0.7071;
        yStep=step*0.7071;
    }
    else if(dir==DIR_RIGHTDOWN)
    {
        xStep=step*0.7071;
        yStep=step*0.7071;
    }
    else
        return;

    Ghost_MoveXY(xStep, yStep, imprecision);
}

void Ghost_MoveXY(float xStep, float yStep, int imprecision)
{
    // If this is sideview, most enemies can't move upward
    if(yStep<0 && IsSideview() && !Ghost_FlagIsSet(GHF_NO_FALL))
        yStep=0;
    
    if(yStep<0)
    {
        // If the enemy's going very fast, move 8 pixels at a time to ensure
        // walkability checking is handled correctly and it moves as far as possible
        if(yStep<-8)
        {
            int yStep2=yStep;
            for(; yStep2<-8; yStep2+=8)
                Ghost_MoveXY(0, -8, imprecision);
            
            // Move all the way
            if(Ghost_CanMove(DIR_UP, -yStep2, imprecision))
                Ghost_Y+=yStep2;
            // Can't go that far; go as far as possible
            // (i.e. snap to the grid on this axis)
            else
                Ghost_Y=Floor(Ghost_Y/8)*8;
        }
        else if(Ghost_CanMove(DIR_UP, -yStep, imprecision))
            Ghost_Y+=yStep;
        else
            Ghost_Y=Floor(Ghost_Y/8)*8;
    }
    else if(yStep>0)
    {
        if(yStep>8)
        {
            int yStep2=yStep;
            for(; yStep2>8; yStep2-=8)
                Ghost_MoveXY(0, 8, imprecision);
            
            if(Ghost_CanMove(DIR_DOWN, yStep2, imprecision))
                Ghost_Y+=yStep2;
            else if(Ghost_Y%8!=0)
                Ghost_Y=Ceiling((Ghost_Y<<0)/8)*8;
        }
        else if(Ghost_CanMove(DIR_DOWN, yStep, imprecision))
            Ghost_Y+=yStep;
        else if(Ghost_Y%8!=0)
            Ghost_Y=Ceiling((Ghost_Y<<0)/8)*8;
    }
    
    if(xStep<0)
    {
        if(xStep<-8)
        {
            int xStep2=xStep;
            for(; xStep2<-8; xStep2+=8)
                Ghost_MoveXY(-8, 0, imprecision);
            
            if(Ghost_CanMove(DIR_LEFT, -xStep2, imprecision))
                Ghost_X+=xStep2;
            else
                Ghost_X=Floor(Ghost_X/8)*8;
        }
        else if(Ghost_CanMove(DIR_LEFT, -xStep, imprecision))
            Ghost_X+=xStep;
        else
            Ghost_X=Floor(Ghost_X/8)*8;
    }
    else if(xStep>0)
    {
        if(xStep>8)
        {
            int xStep2=xStep;
            for(; xStep2>8; xStep2-=8)
                Ghost_MoveXY(8, 0, imprecision);
            
            if(Ghost_CanMove(DIR_RIGHT, xStep2, imprecision))
                Ghost_X+=xStep2;
            else if(Ghost_X%8!=0)
                Ghost_X=Ceiling((Ghost_X<<0)/8)*8;
        }
        else if(Ghost_CanMove(DIR_RIGHT, xStep, imprecision))
            Ghost_X+=xStep;
        else if(Ghost_X%8!=0)
            Ghost_X=Ceiling((Ghost_X<<0)/8)*8;
    }
    
    if(Ghost_FlagIsSet(GHF_SET_DIRECTION) && (__Ghost_InternalFlags&__GHFI_DIR_FORCED)==0)
    {
        // Use 8 directions if 8-way flag is set
        if(Ghost_FlagIsSet(GHF_8WAY))
            Ghost_Dir=AngleDir8(WrapAngle(ArcTan(xStep, yStep))*57.2958);
        
        // Otherwise, 4 directions
        else
        {
            if(Abs(xStep)<Abs(yStep))
            {
                if(yStep<0)
                    Ghost_Dir=DIR_UP;
                else
                    Ghost_Dir=DIR_DOWN;
            }
            else
            {
                if(xStep<0)
                    Ghost_Dir=DIR_LEFT;
                else
                    Ghost_Dir=DIR_RIGHT;
            }
        }
        
        __Ghost_PrevX=Ghost_X;
        __Ghost_PrevY=Ghost_Y;
    }
}

bool Ghost_CanMove(int dir, float step, int imprecision, bool inAir)
{
    if(step==0)
        return true;

    int leftOffset=__Ghost_XOffsets>>8;
    int rightOffset=__Ghost_XOffsets&255;
    int topOffset=__Ghost_YOffsets>>8;
    int bottomOffset=__Ghost_YOffsets&255;

    if(dir==DIR_UP)
    {
        // Most enemies can't move upward on sideview screens
        if(IsSideview() && !Ghost_FlagIsSet(GHF_NO_FALL))
            return false;
        
        int y=Ghost_Y-step;

        // Check every 8 pixels for solid, pit, or water
        for(int i=leftOffset+imprecision; i<Ghost_TileWidth*16-rightOffset-imprecision; i+=8)
        {
            if(!Ghost_CanMovePixel(Ghost_X+i, y+topOffset, inAir))
                return false;
        }

        // One last pixel...
        if(!Ghost_CanMovePixel(Ghost_X+Ghost_TileWidth*16-rightOffset-imprecision-1, y+topOffset, inAir))
            return false;

        return true;
    }
    else if(dir==DIR_DOWN)
    {
        int y=(Ghost_Y+16*Ghost_TileHeight-1)+step;

        for(int i=leftOffset+imprecision; i<Ghost_TileWidth*16-rightOffset-imprecision; i+=8)
        {
            if(!Ghost_CanMovePixel(Ghost_X+i, y-bottomOffset, inAir))
                return false;
        }

        if(!Ghost_CanMovePixel(Ghost_X+Ghost_TileWidth*16-rightOffset-imprecision-1, y-bottomOffset, inAir))
            return false;

        return true;
    }
    else if(dir==DIR_LEFT)
    {
        int x=Ghost_X-step;

        for(int i=topOffset+imprecision; i<Ghost_TileHeight*16-bottomOffset-imprecision; i+=8)
        {
            if(!Ghost_CanMovePixel(x+leftOffset, Ghost_Y+i, inAir))
                return false;
        }

        if(!Ghost_CanMovePixel(x+leftOffset, Ghost_Y+Ghost_TileHeight*16-bottomOffset-imprecision-1, inAir))
            return false;

        return true;
    }
    else if(dir==DIR_RIGHT)
    {
        int x=(Ghost_X+16*Ghost_TileWidth-1)+step;

        for(int i=topOffset+imprecision; i<Ghost_TileHeight*16-bottomOffset-imprecision; i+=8)
        {
            if(!Ghost_CanMovePixel(x-rightOffset, Ghost_Y+i))
                return false;
        }

        if(!Ghost_CanMovePixel(x-rightOffset, Ghost_Y+Ghost_TileHeight*16-bottomOffset-imprecision-1))
            return false;

        return true;
    }
    else if(dir==DIR_LEFTUP)
    {
        float tempX=Ghost_X;

        Ghost_X-=step*0.7071;
        bool ret=Ghost_CanMove(DIR_UP, step*0.7071, imprecision);
        Ghost_X=tempX;
        return ret;
    }
    else if(dir==DIR_RIGHTUP)
    {
        float tempX=Ghost_X;
        Ghost_X+=step*0.7071;
        bool ret=Ghost_CanMove(DIR_UP, step*0.7071, imprecision);
        Ghost_X=tempX;
        return ret;
    }
    else if(dir==DIR_LEFTDOWN)
    {
        float tempX=Ghost_X;
        Ghost_X-=step*0.7071;
        bool ret=Ghost_CanMove(DIR_DOWN, step*0.7071, imprecision);
        Ghost_X=tempX;
        return ret;
    }
    else if(dir==DIR_RIGHTDOWN)
    {
        float tempX=Ghost_X;
        Ghost_X+=step*0.7071;
        bool ret=Ghost_CanMove(DIR_DOWN, step*0.7071, imprecision);
        Ghost_X=tempX;
        return ret;
    }
    else // Invalid direction
        return false;
}

bool Ghost_CanMove(int dir, float step, int imprecision)
{
    return Ghost_CanMove(dir, step, imprecision, Ghost_Z>0);
}

bool Ghost_CanMovePixel(int x, int y, bool inAir)
{
    if(x<0 || x>255 || y<0 || y>175)
        return Ghost_FlagIsSet(GHF_MOVE_OFFSCREEN);
    
    int combo=ComboAt(x, y);
    
    // "No enemy" flags and combos
    if(!Ghost_FlagIsSet(GHF_IGNORE_NO_ENEMY))
    {
        if(Screen->ComboT[combo]==CT_NOENEMY)
            return false;
        if(Screen->ComboF[combo]==CF_NOENEMY)
            return false;
        if(Screen->ComboI[combo]==CF_NOENEMY)
            return false;
        
        // Flying
        if(Ghost_FlagIsSet(GHF_FLYING_ENEMY))
        {
            if(Screen->ComboT[combo]==CT_NOFLYZONE)
                return false;
        }
        // Jumping
        else if(inAir)
        {
            if(Screen->ComboF[combo]==CT_NOJUMPZONE)
                return false;
        }
        // Ground
        else
        {
            if(Screen->ComboT[combo]==CT_NOGROUNDENEMY)
                return false;
            if(Screen->ComboF[combo]==CF_NOGROUNDENEMY)
                return false;
            if(Screen->ComboI[combo]==CF_NOGROUNDENEMY)
                return false;
        }
    }
    
    // Restricted to water
    if(Ghost_FlagIsSet(GHF_DEEP_WATER_ONLY))
        return IsWater(combo);
    
    if(Ghost_FlagIsSet(GHF_WATER_ONLY))
        return IsWater(combo) || Screen->ComboT[combo]==CT_SHALLOWWATER;
    
    // Water and pit walkability override solidity checking
    if(IsWater(combo))
        return Ghost_FlagIsSet(GHF_IGNORE_WATER);
    
    if(IsPit(combo))
        return Ghost_FlagIsSet(GHF_IGNORE_PITS);
    
    // Ignore solidity: always OK
    if(Ghost_FlagIsSet(GHF_IGNORE_SOLIDITY))
        return true;
    
    // Full tile movement: Only if the whole tile is walkable
    else if(Ghost_FlagIsSet(GHF_FULL_TILE_MOVEMENT))
        return __FullTileWalkable(x, y);
    
    // All others: Only if the pixel is walkable
    else
        return !Screen->isSolid(x, y);
}

bool Ghost_CanMovePixel(int x, int y)
{
    return Ghost_CanMovePixel(x, y, Ghost_Z>0);
}

void Ghost_MoveAtAngle(float angle, float step, int imprecision)
{
    Ghost_MoveXY(VectorX(step, angle), VectorY(step, angle), imprecision);
}

void Ghost_MoveTowardLink(float step, int imprecision)
{
    float angle=Angle(Ghost_X+Ghost_TileWidth*8, Ghost_Y+Ghost_TileHeight*8, Link->X+8, Link->Y+8);
    Ghost_MoveXY(VectorX(step, angle), VectorY(step, angle), imprecision);
}

int Ghost_ConstantWalk4(int counter, int step, int rate, int homing, int hunger)
{
    // Don't move while being knocked back
    if(__Ghost_KnockbackCounter>0)
        return counter;
    
    int xStep=0;

    int yStep=0;
    
    // Trying to walk onto half solid combos will throw off the counter
    bool ftmSet=Ghost_FlagIsSet(GHF_FULL_TILE_MOVEMENT);
    if(!Ghost_FlagIsSet(GHF_IGNORE_SOLIDITY))
        Ghost_SetFlag(GHF_FULL_TILE_MOVEMENT);
    
    step/=100;
    
    // If the enemy was knocked back into a wall,
    // check whether it's half a tile off the grid
    if((__Ghost_InternalFlags&__GHFI_KNOCKBACK_INTERRUPTED)!=0)
    {
        // Half a tile off horizontally
        if(Ghost_X%16==8)
        {
            // Fix direction
            bool canMoveLeft=Ghost_CanMove(DIR_LEFT, 1, 0);
            bool canMoveRight=Ghost_CanMove(DIR_RIGHT, 1, 0);
            
            // Can move both left and right (or neither, for some reason)
            if(canMoveLeft==canMoveRight)
            {
                // Don't change direction if already facing left or right
                if(!(Ghost_Dir==DIR_LEFT || Ghost_Dir==DIR_RIGHT))
                    Ghost_Dir=Choose(DIR_LEFT, DIR_RIGHT);
            }
            // Can only move left
            else if(canMoveLeft)
                Ghost_Dir=DIR_LEFT;
            // Can only move right
            else
                Ghost_Dir=DIR_RIGHT;
        }
        
        // Half a tile off vertically
        {
            // Fix direction
            bool canMoveUp=Ghost_CanMove(DIR_UP, 1, 0);
            bool canMoveDown=Ghost_CanMove(DIR_DOWN, 1, 0);
            
            // Can move both up and down (or neither, for some reason)
            if(canMoveUp==canMoveDown)
            {
                // Don't change direction if already facing up or down
                if(!(Ghost_Dir==DIR_UP || Ghost_Dir==DIR_DOWN))
                    Ghost_Dir=Choose(DIR_UP, DIR_DOWN);
            }
            // Can only move up
            else if(canMoveUp)
                Ghost_Dir=DIR_UP;
            // Can only move down
            else
                Ghost_Dir=DIR_DOWN;
        }
        
        counter=Floor(8/step);
    }
    
    if(counter<=0)
    {
        // Snap to grid and maybe turn
        __Ghost_FixCoords();
        __Ghost_NewDir4(rate, homing,hunger);

        if(step==0)
            counter=0;
        else
            counter=Floor(16/step);
    }
    // Turn around after hitting Link
    if(Abs(Ghost_X-Link->X)<16 && Abs(Ghost_Y-Link->Y)<16)
    {
        if(Link->Action==LA_GOTHURTLAND &&
           (__Ghost_InternalFlags&__GHFI_HIT_LINK)==0)
        {
            Ghost_Dir^=1;
            counter=Floor(16/step)-counter;
            __Ghost_InternalFlags|=__GHFI_HIT_LINK;
        }
    }
    // Not touching Link - clear the flag
    else
    {
        __Ghost_InternalFlags&=~__GHFI_HIT_LINK;
    }
    
    // These functions use the full step on both axes for diagonal movement
    if(Ghost_Dir!=DIR_UP && Ghost_Dir!=DIR_DOWN)
    {
        if(Ghost_Dir==DIR_LEFT || Ghost_Dir==DIR_LEFTUP || Ghost_Dir==DIR_LEFTDOWN)
            xStep=-step;
        else // Right
            xStep=step;
    }
    
    if(Ghost_Dir!=DIR_LEFT && Ghost_Dir!=DIR_RIGHT)
    {
        if(Ghost_Dir==DIR_UP || Ghost_Dir==DIR_LEFTUP || Ghost_Dir==DIR_RIGHTUP)
            yStep=-step;
        else // Down
            yStep=step;
    }
    
    // Restore the flag
    if(!ftmSet)
        Ghost_UnsetFlag(GHF_FULL_TILE_MOVEMENT);
    
    Ghost_MoveXY(xStep, yStep, 0);
    return counter-1;
}

int Ghost_ConstantWalk8(int counter, int step, int rate, int homing, int hunger)
{
    // Don't move while being knocked back
    if(__Ghost_KnockbackCounter>0)
        return counter;


    int xStep=0;
    int yStep=0;
    step/=100;

    if(counter<=0)
    {
        // Turn
        __Ghost_NewDir8(rate, homing, hunger);
        counter=Floor(8/step);
    }

    // Needs to snap to the grid, so Ghost_Move() would be problematic
    if(Ghost_Dir!=DIR_UP && Ghost_Dir!=DIR_DOWN)

    {
        if(Ghost_Dir==DIR_LEFT || Ghost_Dir==DIR_LEFTUP || Ghost_Dir==DIR_LEFTDOWN)
            xStep=-step;
        else // Right
            xStep=step;

    }

    if(Ghost_Dir!=DIR_LEFT && Ghost_Dir!=DIR_RIGHT)
    {
        if(Ghost_Dir==DIR_UP || Ghost_Dir==DIR_LEFTUP || Ghost_Dir==DIR_RIGHTUP)
            yStep=-step;
        else // Down
            yStep=step;
    }

    Ghost_MoveXY(xStep, yStep, 0);
    return counter-1;
}

float Ghost_HaltingWalk4(int counter, int step, int rate, int homing, int hunger, int haltRate, int haltTime)
{
    // Don't move while being knocked back
    if(__Ghost_KnockbackCounter>0)
        return counter;
    
    // The counter is actually two combined...
    int walkCounter;
    int haltCounter;
    
    if(counter==-1)
    {
        walkCounter=0;
        haltCounter=0;
    }
    else
    {
        walkCounter=counter*10000;
        haltCounter=counter>>0;
    }
    
    // Halted; just count down
    if(haltCounter>0)
        return haltCounter-1;
    
    // Trying to walk onto half solid combos will throw off the counter
    bool ftmSet=Ghost_FlagIsSet(GHF_FULL_TILE_MOVEMENT);
    if(!Ghost_FlagIsSet(GHF_IGNORE_SOLIDITY))
        Ghost_SetFlag(GHF_FULL_TILE_MOVEMENT);
    
    step/=100;
    
    // If the enemy was knocked back into a wall,
    // check whether it's half a tile off the grid
    if((__Ghost_InternalFlags&__GHFI_KNOCKBACK_INTERRUPTED)!=0)
    {
        // Half a tile off horizontally
        if(Ghost_X%16==8)
        {
            // Fix direction
            bool canMoveLeft=Ghost_CanMove(DIR_LEFT, 1, 0);
            bool canMoveRight=Ghost_CanMove(DIR_RIGHT, 1, 0);
            
            // Can move both left and right (or neither, for some reason)
            if(canMoveLeft==canMoveRight)
            {
                // Don't change direction if already facing left or right
                if(!(Ghost_Dir==DIR_LEFT || Ghost_Dir==DIR_RIGHT))
                    Ghost_Dir=Choose(DIR_LEFT, DIR_RIGHT);
            }
            // Can only move left
            else if(canMoveLeft)
                Ghost_Dir=DIR_LEFT;
            // Can only move right
            else
                Ghost_Dir=DIR_RIGHT;
        }
        
        // Half a tile off vertically
        {
            // Fix direction
            bool canMoveUp=Ghost_CanMove(DIR_UP, 1, 0);
            bool canMoveDown=Ghost_CanMove(DIR_DOWN, 1, 0);
            
            // Can move both up and down (or neither, for some reason)
            if(canMoveUp==canMoveDown)
            {
                // Don't change direction if already facing up or down
                if(!(Ghost_Dir==DIR_UP || Ghost_Dir==DIR_DOWN))
                    Ghost_Dir=Choose(DIR_UP, DIR_DOWN);
            }
            // Can only move up
            else if(canMoveUp)
                Ghost_Dir=DIR_UP;
            // Can only move down
            else
                Ghost_Dir=DIR_DOWN;
        }
        
        walkCounter=Floor(8/step);
    }
    
    if(walkCounter==0)
    {
        // Snap to the grid and possibly turn
        __Ghost_FixCoords();
        walkCounter=Floor(16/step);

        if(counter==-1)
        {
            __Ghost_NewDir4(rate, homing, hunger);

            // Halt?
            if(Rand(16)<haltRate)
            {
                if(!ftmSet)
                    Ghost_UnsetFlag(GHF_FULL_TILE_MOVEMENT);
                haltCounter=haltTime;
                return haltCounter;
            }
        }
    }
    
    // Turn around after hitting Link
    if(Abs(Ghost_X-Link->X)<16 && Abs(Ghost_Y-Link->Y)<16)
    {
        if(Link->Action==LA_GOTHURTLAND &&
           (__Ghost_InternalFlags&__GHFI_HIT_LINK)==0)
        {
            Ghost_Dir^=1;
            walkCounter=Floor(16/step)-walkCounter;
            __Ghost_InternalFlags|=__GHFI_HIT_LINK;
        }
    }
    // Not touching Link - clear the flag
    else
    {
        __Ghost_InternalFlags&=~__GHFI_HIT_LINK;
    }
    
    walkCounter--;
    Ghost_Move(Ghost_Dir, step, 0);
    
    if(!ftmSet)
        Ghost_UnsetFlag(GHF_FULL_TILE_MOVEMENT);
    
    if(walkCounter>0)
        return walkCounter/10000;
    else
        return -1;
}

int Ghost_VariableWalk8(int counter, int step, int rate, int homing, int hunger, int turnCheckTime)
{
    // Don't move while being knocked back
    if(__Ghost_KnockbackCounter>0)
        return counter;

    step/=100;

    if(!Ghost_CanMove(Ghost_Dir, step, 0))
        counter=0;

    // Time to turn?
    if(counter<=0)
    {
        __Ghost_NewDir8(rate, homing, hunger);
        counter=turnCheckTime;
    }

    Ghost_Move(Ghost_Dir, step, 0);
    return counter-1;
}


// ======================
// |||| MODIFICATION ||||
// ======================

void Ghost_Transform(ffc this, npc ghost, int combo, int cset, int tileWidth, int tileHeight)
{
    int diff;

    if(combo>=0)
    {
        Ghost_Data=combo;
        this->Data=combo;
    }

    if(cset>=0)
    {
        Ghost_CSet=cset;
        this->CSet=cset;
        ghost->CSet=cset;

    }

    if(tileWidth>0)
    {
        diff=8*(Ghost_TileWidth-tileWidth);
        Ghost_TileWidth=tileWidth;
        ghost->TileWidth=Ghost_TileWidth;
        this->TileWidth=Ghost_TileWidth;

        Ghost_X+=diff;
        this->X=Ghost_X;
        ghost->X=Ghost_X;
    }

    if(tileHeight>0)
    {
        diff=8*(Ghost_TileHeight-tileHeight);
        Ghost_TileHeight=tileHeight;
        ghost->TileHeight=Ghost_TileHeight;
        this->TileHeight=Ghost_TileHeight;

        Ghost_Y+=diff;
        this->Y=Ghost_Y;
        ghost->Y=Ghost_Y;
    }

    Ghost_SetHitOffsets(ghost, 0, 0, 0, 0);
}

void Ghost_SwapNPC(npc oldGhost, npc newGhost, bool copyHP)
{
    newGhost->X=Ghost_X;
    newGhost->Y=Ghost_Y;
    newGhost->Z=Ghost_Z;
    newGhost->Jump=Ghost_Jump;
    newGhost->Dir=Ghost_Dir;

    newGhost->Extend=oldGhost->Extend;
    newGhost->TileWidth=oldGhost->TileWidth;
    newGhost->TileHeight=oldGhost->TileHeight;
    newGhost->HitWidth=oldGhost->HitWidth;
    newGhost->HitHeight=oldGhost->HitHeight;
    newGhost->HitXOffset=oldGhost->HitXOffset;
    newGhost->HitYOffset=oldGhost->HitYOffset;
    newGhost->CollDetection=oldGhost->CollDetection;

    for(int i=0; i<16; i++)
        newGhost->Misc[i]=oldGhost->Misc[i];

    if(copyHP)
        newGhost->HP=oldGhost->HP;

    // Move the old ghost out of the way
    oldGhost->CollDetection=false;
    oldGhost->X=256;
    oldGhost->Y=176;
}

void Ghost_ReplaceNPC(npc oldGhost, npc newGhost, bool copyHP)
{
    Ghost_SwapNPC(oldGhost, newGhost, copyHP);

    oldGhost->X=384;
    oldGhost->HP=-1000;
}

void Ghost_SetHitOffsets(npc ghost, float top, float bottom, float left, float right)

{
    if(top>0 && top<1)
        top=Round(top*Ghost_TileHeight*16);
    if(bottom>0 && bottom<1)
        bottom=Round(bottom*Ghost_TileHeight*16);
    if(left>0 && left<1)
        left=Round(left*Ghost_TileWidth*16);
    if(right>0 && right<1)
        right=Round(right*Ghost_TileWidth*16);

    top=VBound(top, 64, 0);
    bottom=VBound(bottom, 64, 0);
    left=VBound(left, 64, 0);
    right=VBound(right, 64, 0);

    ghost->HitXOffset=left;
    ghost->HitYOffset=top;
    ghost->HitWidth=16*Ghost_TileWidth-(left+right);
    ghost->HitHeight=16*Ghost_TileHeight-(top+bottom);

    __Ghost_XOffsets=(left<<8)+right;
    __Ghost_YOffsets=(top<<8)+bottom;
}

void Ghost_StoreDefenses(npc ghost, int storedDefense)
{
    for(int i=0; i<18; i++)
        storedDefense[i]=ghost->Defense[i];
}

void Ghost_SetDefenses(npc ghost, int defense)
{
    for(int i=0; i<18; i++)
        ghost->Defense[i]=defense[i];
}

void Ghost_SetAllDefenses(npc ghost, int defType)
{
    for(int i=0; i<18; i++)
        ghost->Defense[i]=defType;
}

void Ghost_ForceDir(int dir)
{
    Ghost_Dir=dir;
    __Ghost_InternalFlags|=__GHFI_DIR_FORCED;
}

void Ghost_ForceCSet(int cset)
{
    Ghost_CSet=cset;
    __Ghost_InternalFlags|=__GHFI_CSET_FORCED;
}

void Ghost_StartFlashing()
{
    __Ghost_FlashCounter=32;
}

void Ghost_StartFlashing(int time)
{
    __Ghost_FlashCounter=time;
}

void Ghost_StopFlashing()
{
    __Ghost_FlashCounter=0;
    __Ghost_InternalFlags&=~__GHFI_FLICKER;
}

void Ghost_StopKnockback()
{
    __Ghost_KnockbackCounter=0;
}


// =======================
// |||| MULTIPLE FFCS ||||
// =======================

bool Ghost_SetAttachedFFCs(int attachedFFCs, bool forceTrueFFCs)
{
    // Clear FFCs
    if(attachedFFCs<=0)
    {
        __Ghost_AttachedFFCs=0;
        return true;
    }
    
    // Check that the number of array elements is valid; print an error if not
    int arraySize=SizeOfArray(attachedFFCs);
    
    if(arraySize==0 || arraySize%__GH_FFC_SIZE!=0)
    {
        int error1[]="ghost.zh: Invalid array passed to Ghost_SetAttachedFFCs.\n";
        int error2[30]="  DMap %d, screen %X\n";
        int error3[60]="  Array size is %d; must be a multiple of %d.\n";
        printf(error1);
        printf(error2, Game->GetCurDMap(), Game->GetCurDMapScreen());
        printf(error3, arraySize, __GH_FFC_SIZE);
        __Ghost_AttachedFFCs=0;
        return false;
    }
    
    __Ghost_AttachedFFCs=attachedFFCs;
    
    // If DrawCombo is used, this doesn't actually require multiple FFCs;
    // if real FFCs weren't forced, clear FFC numbers to avoid confusion
    if(__GH_USE_DRAWCOMBO!=0 && !forceTrueFFCs)
    {
        for(int i=0; i<arraySize; i+=__GH_FFC_SIZE)
            __Ghost_AttachedFFCs[i]=0;
        
        return true;
    }
    
    // DrawCombo is disabled or real FFCs were requested, so set up the FFCs
    int unusedFFC=0;
    ffc f;
    
    for(int i=0; i<arraySize; i+=__GH_FFC_SIZE)
    {
        // Find an FFC automatically
        if(__Ghost_AttachedFFCs[i]<=0)
        {
            unusedFFC=FindUnusedFFC(unusedFFC);
            
            // Failed to find an FFC?
            if(unusedFFC==0)
            {
                Ghost_ClearAttachedFFCs();
                return false;
            }
            
            // FFC's okay
            else
                __Ghost_AttachedFFCs[i]=unusedFFC;
        }
        
        // Set the FFC's data so it doesn't appear unused later
        f=Screen->LoadFFC(unusedFFC);
        f->Data=GH_INVISIBLE_COMBO;
    }
    
    // Success
    return true;
}

void Ghost_ModifyAttachedFFC(int whichFFC, int whichDatum, int newValue)
{
    if(__Ghost_AttachedFFCs==0)
        return;
    
    __Ghost_AttachedFFCs[whichFFC*__GH_FFC_SIZE+whichDatum]=newValue;
}

void Ghost_HideAttachedFFCs()
{
    if(__Ghost_AttachedFFCs==0)
        return;
    
    int arraySize=SizeOfArray(__Ghost_AttachedFFCs);
    
    for(int i=GH_FFC_FLAGS; i<arraySize; i+=__GH_FFC_SIZE)
        __Ghost_AttachedFFCs[i]|=GH_FFCF_HIDDEN;
}

void Ghost_UnhideAttachedFFCs()
{
    if(__Ghost_AttachedFFCs==0)
        return;
    
    int arraySize=SizeOfArray(__Ghost_AttachedFFCs);
    
    for(int i=GH_FFC_FLAGS; i<arraySize; i+=__GH_FFC_SIZE)
        __Ghost_AttachedFFCs[i]&=~GH_FFCF_HIDDEN;
}

void Ghost_ClearAttachedFFCs()
{
    if(__Ghost_AttachedFFCs==0)
        return;
    
    int arraySize=SizeOfArray(__Ghost_AttachedFFCs);
    ffc f;
    
    // Load each FFC and clear it
    for(int i=0; i<arraySize; i+=__GH_FFC_SIZE)
    {
        if(__Ghost_AttachedFFCs[i]==0)
            continue;
        
        f=Screen->LoadFFC(__Ghost_AttachedFFCs[i]);
        f->Data=0;
        __Ghost_AttachedFFCs[i]=0;
    }
    
    __Ghost_AttachedFFCs=0;
}

int Ghost_GetAttachedFFC(int whichFFC)
{
    if(__Ghost_AttachedFFCs==0)
        return 0;
    
    return __Ghost_AttachedFFCs[whichFFC*__GH_FFC_SIZE];
}

// ===============
// |||| OTHER ||||
// ===============

void AutoGhost()
{
    npc enemy;
    int ffcID=0;
    ffc f;

    // Search enemies for one that should be autoghosted
    for(int i=Screen->NumNPCs(); i>0; i--)
    {
        enemy=Screen->LoadNPC(i);

        // ID out of range??
        if(enemy->ID<AUTOGHOST_MIN_ENEMY_ID || enemy->ID>AUTOGHOST_MAX_ENEMY_ID)
            continue;

        // Already in use?
        if(enemy->Misc[__GHI_IN_USE]!=0)
            continue;

        // No combo or script set?
        if(enemy->Attributes[10]==0 || enemy->Attributes[11]==0)
            continue;

        // Found an enemy that needs ghosted; now find an FFC
        ffcID=FindUnusedFFC(ffcID);

        // No suitable FFC? Kill the enemy, then
        if(ffcID==0)
        {
            enemy->X=256;
            enemy->Y=176;
            enemy->ItemSet=0;
            enemy->HP=-1000;
        }
        // Found an FFC; set it up
        else
        {
            f=Screen->LoadFFC(ffcID);
            f->Data=GH_INVISIBLE_COMBO;
            f->CSet=enemy->CSet;
            f->Script=enemy->Attributes[11];
            f->InitD[0]=enemy->ID;
            f->X=enemy->X;
            f->Y=enemy->Y-enemy->Z;
            f->Vx=0;
            f->Vy=0;
            f->Ax=0;
            f->Ay=0;

            // Setting this in advance hides the spawn animation, so it's not visible for a
            // single frame before the script starts (assuming this is after Waitdraw())
            if(enemy->Attributes[10]!=GH_INVISIBLE_COMBO &&
               enemy->Attributes[10]!=__GH_INVISIBLE_ALT)
                enemy->Extend=3;
        }
    }
}

void CleanUpGhostFFCs()
{
    // Hide FFCs when Link is dead
    if(Link->HP<=0 && __GH_USE_DRAWCOMBO==0)
    {
        ffc f;
        for(int i=1; i<=32; i++)
        {
            f=Screen->LoadFFC(i);
            if((__Ghost_Scripts[f->Script>>4]&(1<<(f->Script&1111b)))!=0)
                f->Data=0;
        }
    }
}

npc SpawnNPC(int id)
{
    int tileRatings[176];
    int checkCombo;
    int bestRating;
    int bestCount;
    int counter;
    int choice;
    int tries;

    npc checkNPC;
    npc theNPC;

    // First, rate each tile for suitability. Lower is better, but negative means it's strictly off-limits.

    // Tiles used by or next to other NPCs are undesirable
    for(int i=Screen->NumNPCs(); i>0; i--)
    {
        checkNPC=Screen->LoadNPC(i);
        checkCombo=ComboAt(checkNPC->X, checkNPC->Y);
        tileRatings[checkCombo]+=100;

        if(checkCombo>15)
            tileRatings[checkCombo-16]+=1;
        if(checkCombo<160)
            tileRatings[checkCombo+16]+=1;
        if(checkCombo%16>0)
            tileRatings[checkCombo-1]+=1;
        if(checkCombo%16<15)
            tileRatings[checkCombo+1]+=1;
    }

    // Mark other prohibited tiles
    for(int i=0; i<176; i++)
    {
        // Screen edges in NES dungeon
        if((Screen->Flags[SF_ROOMTYPE]&010b)!=0 && (i<32 || i>143 || i%16<2 || i%16>13))
            tileRatings[i]=-1;
        // "No enemy" flag and combos
        else if(Screen->ComboF[i]==CF_NOENEMY || Screen->ComboI[i]==CF_NOENEMY ||
                Screen->ComboT[i]==CT_NOENEMY || Screen->ComboT[i]==CT_NOFLYZONE ||
                Screen->ComboT[i]==CT_NOJUMPZONE)
            tileRatings[i]=-1;
        // Water and pits
        else if(IsWater(i) || IsPit(i))
            tileRatings[i]=-1;
        // Solid combos
        else if(Screen->ComboS[i]!=0)
            tileRatings[i]=-1;
    }

    // Find the best rating and count the number of tiles with that rating
    bestRating=10000;
    bestCount=0;
    for(int i=0; i<176; i++)
    {
        if(tileRatings[i]<0)
            continue;

        if(tileRatings[i]==bestRating)
            bestCount++;
        else if(tileRatings[i]<bestRating)
        {
            bestRating=tileRatings[i];
            bestCount=1;
        }

    }

    // Pick at random from the best rated tiles, but pick again if it's too close to Link
    do {
        counter=Rand(bestCount)+1;
        for(choice=0; counter>0; choice++)
        {
            if(tileRatings[choice]==bestRating)
                counter--;
        }

        // Limit the number of tries to ensure this doesn't become an infinite loop
        tries++;
    } while(Distance(ComboX(choice), ComboY(choice), Link->X, Link->Y)<40 && tries<256)
    
    
    theNPC=Screen->CreateNPC(id);
    theNPC->X=ComboX(choice-1);
    theNPC->Y=ComboY(choice-1);
    return theNPC;
}

int FindUnusedFFC()
{
    return FindUnusedFFC(0);
}

int FindUnusedFFC(int startingFrom)
{
    ffc f;
    
    for(int i=Max(startingFrom+1, AUTOGHOST_MIN_FFC); i<=AUTOGHOST_MAX_FFC; i++)
    {
        f=Screen->LoadFFC(i);
        
        if(f->Data==0 && f->Script==0)
            return i;
    }
    
    // Couldn't find one
    return 0;
}

void Ghost_SpawnAnimationPuff(ffc this, npc ghost)
{
    lweapon graphic;
    int combo=this->Data;
    bool collDet=ghost->CollDetection;
    int xOffset=ghost->DrawXOffset;
    
    if(this->TileWidth!=Ghost_TileWidth)
    {
        this->TileWidth=Ghost_TileWidth;
        ghost->TileWidth=Ghost_TileWidth;
        ghost->HitWidth=16*Ghost_TileWidth;
        ghost->HitXOffset=0;
    }
    
    if(this->TileHeight!=Ghost_TileHeight)
    {
        this->TileHeight=Ghost_TileHeight;
        ghost->TileHeight=Ghost_TileHeight;
        ghost->HitHeight=16*Ghost_TileHeight;
        ghost->HitYOffset=0;
    }
    
    Ghost_SetPosition(this, ghost);
    
    this->Data=0;
    ghost->CollDetection=false;
    ghost->DrawXOffset=32768;
    
    for(int i=0; i<this->TileWidth; i++)
    {
        for(int j=0; j<this->TileHeight; j++)
        {
            graphic=Screen->CreateLWeapon(LW_SCRIPT10);
            graphic->CollDetection=false;
            graphic->UseSprite(GH_SPAWN_SPRITE);
            graphic->X=this->X+16*i;
            graphic->Y=this->Y+16*j;
            
            if(graphic->NumFrames==0)
                graphic->NumFrames=3;
            if(graphic->ASpeed==0)
                graphic->ASpeed=4;
            
            graphic->DeadState=graphic->NumFrames*graphic->ASpeed;
        }
    }
    
    for(int i=graphic->NumFrames*graphic->ASpeed; i>0; i--)
    {
        Ghost_SetPosition(this, ghost);
        Ghost_WaitframeLight(this, ghost);
    }
    
    this->Data=combo;
    ghost->CollDetection=collDet;
    ghost->DrawXOffset=xOffset;
}

void Ghost_SpawnAnimationFlicker(ffc this, npc ghost)
{
    int combo=this->Data;
    bool collDet=ghost->CollDetection;
    int xOffset=ghost->DrawXOffset;
    
    if(this->TileWidth!=Ghost_TileWidth)
    {
        this->TileWidth=Ghost_TileWidth;
        ghost->TileWidth=Ghost_TileWidth;
        ghost->HitWidth=16*Ghost_TileWidth;
        ghost->HitXOffset=0;
    }
    
    if(this->TileHeight!=Ghost_TileHeight)
    {
        this->TileHeight=Ghost_TileHeight;
        ghost->TileHeight=Ghost_TileHeight;
        ghost->HitHeight=16*Ghost_TileHeight;
        ghost->HitYOffset=0;
    }
    
    Ghost_SetPosition(this, ghost);
    ghost->CollDetection=false;
    
    // Alternate drawing offscreen and in place for 64 frames
    for(int i=0; i<32; i++)
    {
        this->Data=0;
        ghost->DrawXOffset=32768;
        Ghost_SetPosition(this, ghost);
        Ghost_WaitframeLight(this, ghost);
        
        this->Data=combo;
        ghost->DrawXOffset=xOffset;
        Ghost_SetPosition(this, ghost);
        Ghost_WaitframeLight(this, ghost);
    }
    
    this->Data=combo;
    ghost->CollDetection=collDet;
    ghost->DrawXOffset=xOffset;
}

bool Ghost_GotHit()
{
    return (__Ghost_InternalFlags&__GHFI_GOT_HIT)!=0;
}

void Ghost_Explode(ffc this, npc ghost)
{
    lweapon explosion;
    npc deathSFXNPC;

    // The enemy's death sound should play at the start of the animation, but the enemy has to stay
    // alive until the end. There isn't a good way to do that, so here's a stupid way, instead.
    // Make another of the same enemy, hide it, and kill it. After the animation finishes,
    // kill the real one silently.
    
    deathSFXNPC=Screen->CreateNPC(ghost->ID);
    deathSFXNPC->X=ghost->X; // For panning
    deathSFXNPC->Y=176;
    deathSFXNPC->ItemSet=0;
    deathSFXNPC->HP=0;
    deathSFXNPC->Misc[__GHI_IN_USE]=1;
    
    this->CSet=Ghost_CSet;
    this->Flags[FFCF_OVERLAY]=false;
    this->Vx=0;
    this->Vy=0;
    this->Ax=0;
    this->Ay=0;
    ghost->HP=1;
    ghost->CollDetection=false;
    ghost->SFX=0;
    Ghost_StopFlashing();
    
    // One explosion every 16 frames, 15 times
    for(int i=0; i<15; i++)
    {
        explosion=Screen->CreateLWeapon(LW_BOMBBLAST);
        explosion->X=Ghost_X+ghost->DrawXOffset+Rand(16*Ghost_TileWidth)-8;
        explosion->Y=Ghost_Y-Ghost_Z+ghost->DrawYOffset-ghost->DrawZOffset+Rand(16*Ghost_TileHeight)-8;
        explosion->CollDetection=false;
        for(int j=0; j<16; j++)
        {
            Ghost_SetPosition(this, ghost);
            Ghost_WaitframeLight(this, ghost);
        }
    }

    ghost->X=1024;
    this->Data=GH_INVISIBLE_COMBO;
    Ghost_Data=GH_INVISIBLE_COMBO;
    Ghost_ClearAttachedFFCs();
}

void Ghost_SetPosition(ffc this, npc ghost)
{
    // Real Z
    if(GH_FAKE_Z==0 && !Ghost_FlagIsSet(GHF_FAKE_Z))
    {
        ghost->X=Ghost_X;
        ghost->Y=Ghost_Y;
        ghost->Z=Ghost_Z;
    }

    // Fake Z
    else
    {
        ghost->X=Ghost_X;
        ghost->Y=Ghost_Y-Ghost_Z;
        ghost->Z=0;
    }

    // Don't let the FFC go too far offscreen, or else it will disappear
    this->X=VBound(Ghost_X+ghost->DrawXOffset, 256, -64);
    this->Y=VBound(Ghost_Y-Ghost_Z+ghost->DrawYOffset-ghost->DrawZOffset, 176, -64);
}

void Ghost_MarkAsInUse(npc ghost)
{
    ghost->Misc[__GHI_IN_USE]=1;
}

bool Ghost_IsInUse(npc ghost)
{
    return ghost->Misc[__GHI_IN_USE]==1;
}


// =================
// |||| EWEAPON ||||
// =================

// Fire an eweapon
eweapon FireEWeapon(int weaponID, int x, int y, float angle, int step, int damage, int sprite, int sound, int flags)
{
    eweapon wpn=Screen->CreateEWeapon(weaponID);
    wpn->X=x;
    wpn->Y=y;
    wpn->Step=step;
    wpn->Damage=damage;
    wpn->Angular=true;
    wpn->Angle=angle;
    SetEWeaponDir(wpn);
    
    if(sprite>=0)
        wpn->UseSprite(sprite);
    
    wpn->Misc[__EWI_FLAGS]=flags|__EWFI_IS_GHZH_EWPN;
    
    if((wpn->Misc[__EWI_FLAGS]&EWF_ROTATE)!=0)
        SetEWeaponRotation(wpn);
        
    Game->PlaySound(sound);
    
    return wpn;
}

// Fire an eweapon aimed based on Link's position
eweapon FireAimedEWeapon(int weaponID, int x, int y, float angle, int step, int damage, int sprite, int sound, int flags)
{
    return FireEWeapon(weaponID, x, y, ArcTan(Link->X-x, Link->Y-y)+angle, step, damage, sprite, sound, flags);
}

// Fire a non-angular eweapon
eweapon FireNonAngularEWeapon(int weaponID, int x, int y, int direction, int step, int damage, int sprite, int sound, int flags)
{
    eweapon wpn=Screen->CreateEWeapon(weaponID);
    wpn->X=x;
    wpn->Y=y;
    wpn->Dir=direction;
    wpn->Step=step;
    wpn->Damage=damage;
    if(sprite>=0)
        wpn->UseSprite(sprite);

    wpn->Misc[__EWI_FLAGS]=flags|__EWFI_IS_GHZH_EWPN;

    if((wpn->Misc[__EWI_FLAGS]&EWF_NO_COLLISION)!=0)
        wpn->CollDetection=false;

    if((wpn->Misc[__EWI_FLAGS]&EWF_ROTATE)!=0)
        SetEWeaponRotation(wpn);

    Game->PlaySound(sound);
    return wpn;
}

// Fire an eweapon larger than 1x1
eweapon FireBigEWeapon(int weaponID, int x, int y, float angle, int step, int damage, int sprite, int sound, int flags, int width, int height)
{
    eweapon wpn=FireEWeapon(weaponID, x, y, angle, step, damage, sprite, sound, flags);
    wpn->Extend=3;
    wpn->TileWidth=width;
    wpn->TileHeight=height;
    wpn->HitWidth=16*width;
    wpn->HitHeight=16*height;
    return wpn;
}

// Fire an eweapon larger than 1x1 aimed based on Link's position
eweapon FireBigAimedEWeapon(int weaponID, int x, int y, float angle, int step, int damage, int sprite, int sound, int flags, int width, int height)
{
    eweapon wpn=FireEWeapon(weaponID, x, y, ArcTan(Link->X-x, Link->Y-y)+angle, step, damage, sprite, sound, flags);
    wpn->Extend=3;
    wpn->TileWidth=width;
    wpn->TileHeight=height;
    wpn->HitWidth=16*width;
    wpn->HitHeight=16*height;
    return wpn;
}

// Fire a non-angular eweapon larger than 1x1
eweapon FireBigNonAngularEWeapon(int weaponID, int x, int y, int direction, int step, int damage, int sprite, int sound, int flags, int width, int height)
{
    eweapon wpn=FireNonAngularEWeapon(weaponID, x, y, direction, step, damage, sprite, sound, flags);
    wpn->Extend=3;
    wpn->TileWidth=width;
    wpn->TileHeight=height;
    wpn->HitWidth=16*width;
    wpn->HitHeight=16*height;
    return wpn;
}

// Create a dummy eweapon to use as a prototype
eweapon CreateDummyEWeapon(int weaponID, int step, int damage, int sprite, int sound, int flags)
{
    eweapon wpn=Screen->CreateEWeapon(weaponID);
    eweapon checkWpn;
    int minID;
    wpn->Step=0;
    wpn->Damage=damage;
    wpn->Misc[__EWI_DUMMY_STEP]=step;
    wpn->Misc[__EWI_DUMMY_SOUND]=sound;
    wpn->Misc[__EWI_DUMMY_SPRITE]=sprite;

    // Give the weapon a unique ID number so it can be found later
    for(int i=Screen->NumEWeapons(); i>0; i--)
    {
        checkWpn=Screen->LoadEWeapon(i);
        if((checkWpn->Misc[__EWI_FLAGS]&__EWFI_DUMMY_CHECK)==__EWFI_DUMMY_CHECK)
            continue;
        minID=Min(minID, checkWpn->Misc[__EWI_ID]);
    }
    wpn->Misc[__EWI_ID]=minID-1;

    wpn->Misc[__EWI_FLAGS]=flags|__EWFI_IS_GHZH_EWPN|__EWFI_DUMMY;

    wpn->CollDetection=false;
    wpn->DrawXOffset=32768;

    return wpn;
}

// Create a dummy eweapon larger than 1x1
eweapon CreateBigDummyEWeapon(int weaponID, int step, int damage, int sprite, int sound, int flags, int width, int height)
{
    eweapon wpn=CreateDummyEWeapon(weaponID, step, damage, sprite, sound, flags);
    wpn->Extend=3;

    wpn->TileWidth=width;
    wpn->TileHeight=height;
    // No point setting HitWidth and HitHeight here
    return wpn;
}

// Set an eweapon's movement type
void SetEWeaponMovement(eweapon wpn, int type, int arg)
{
    wpn->Misc[__EWI_XPOS]=wpn->X;
    wpn->Misc[__EWI_YPOS]=wpn->Y;
    wpn->Misc[__EWI_WORK]=0;
    wpn->Misc[__EWI_MOVEMENT]=type;
    wpn->Misc[__EWI_MOVEMENT_ARG]=arg;
    wpn->Misc[__EWI_FLAGS]|=__EWFI_IS_GHZH_EWPN;

    if(type==EWM_HOMING_REAIM || type==EWM_RANDOM_REAIM)
    {
        // Dummy? Use its stored step instead of its real step
        if((wpn->Misc[__EWI_FLAGS]&__EWFI_DUMMY)!=0)
            wpn->Misc[__EWI_WORK_2]=wpn->Misc[__EWI_DUMMY_STEP];
        else
            wpn->Misc[__EWI_WORK_2]=wpn->Step;
    }
    else if(type>=EWM_THROW && type<=EWM_THROW_BOUNCE_STOP)
    {
        wpn->Misc[__EWI_WORK_2]=wpn->Z;

        // Necessary upward velocity to reach Link for thrown weapons
        if(arg<=0)
        {
            // Special case for dummy weapons
            if((wpn->Misc[__EWI_FLAGS]&__EWFI_DUMMY)!=0)
                wpn->Misc[__EWI_MOVEMENT_ARG]=-1;

            // A rough approximation, but it should be close enough
            else
            {
                float time=Distance(wpn->X, wpn->Y, Link->X, Link->Y)/(wpn->Step/100);
                wpn->Misc[__EWI_MOVEMENT_ARG]=GH_GRAVITY*time/2;
            }
        }
    }
    else if(type==EWM_FALL)
    {
        wpn->Z=arg;
        wpn->Misc[__EWI_WORK]=GH_GRAVITY;
    }
}

// Set an eweapon's lifespan
void SetEWeaponLifespan(eweapon wpn, int type, int arg)
{
    wpn->Misc[__EWI_LIFESPAN]=type;
    wpn->Misc[__EWI_LIFESPAN_ARG]=arg;
    wpn->Misc[__EWI_FLAGS]|=__EWFI_IS_GHZH_EWPN;
}

// Set an eweapon to use a standard death effect
void SetEWeaponDeathEffect(eweapon wpn, int type, int arg)
{
    wpn->Misc[__EWI_ON_DEATH]=type;
    wpn->Misc[__EWI_ON_DEATH_ARG]=arg;
    wpn->Misc[__EWI_FLAGS]|=__EWFI_IS_GHZH_EWPN;
}

// Set an eweapon to spawn more eweapons on death
void SetEWeaponDeathEffect(eweapon wpn, eweapon prototype, int numShots, int spreadType, float angle)
{
    // Combining four variables into two... Ugly, but doable
    wpn->Misc[__EWI_ON_DEATH]=prototype->Misc[__EWI_ID]+(numShots%1000)/10000;
    wpn->Misc[__EWI_ON_DEATH_ARG]=spreadType*100+(WrapAngle(angle)+6.2832);
    wpn->Misc[__EWI_FLAGS]|=__EWFI_IS_GHZH_EWPN;
}

// Update a weapon's movement, lifespan, and death effects
void UpdateEWeapon(eweapon wpn)
{
    // Start flags

    // Unblockable
    if((wpn->Misc[__EWI_FLAGS]&EWF_UNBLOCKABLE)!=0)
    {
        // A weapon is made unblockable by setting its direction to match Link's each frame
        wpn->Dir=Link->Dir;
        if((wpn->Misc[__EWI_FLAGS]&EWF_ROTATE)!=0)
            SetEWeaponRotation(wpn);
    }

    // Flicker
    if((wpn->Misc[__EWI_FLAGS]&EWF_FLICKER)!=0)
    {
        // Weapons can't be made invisible; use DrawXOffset instead
        if(wpn->DrawXOffset<1000)
            wpn->DrawXOffset+=1000;
        else
            wpn->DrawXOffset-=1000;
    }

    // Shadow
    if((wpn->Misc[__EWI_FLAGS]&EWF_SHADOW)!=0)
    {
        if(GH_SHADOW_FLICKER!=0)
        {
            // Draw every other frame
            if((wpn->Misc[__EWI_FLAGS]&__EWFI_SHADOW_FLICKER)==0)
                wpn->Misc[__EWI_FLAGS]|=__EWFI_SHADOW_FLICKER;
            else
            {
                if(wpn->Z>0)
                    DrawEWeaponShadow(wpn);
                wpn->Misc[__EWI_FLAGS]&=~__EWFI_SHADOW_FLICKER;
            }
        }
        else if(wpn->Z>0)
            DrawEWeaponShadow(wpn);
    }

    // End flags

    // Is the weapon still active?
    if((wpn->Misc[__EWI_FLAGS]&__EWFI_DEAD)==0)
    {
        // Start movement updates
        if(wpn->Misc[__EWI_MOVEMENT]!=0)
        {
            // Split in half to reduce checks
            if(wpn->Misc[__EWI_MOVEMENT]<15)
            {
                // Sine wave
                if(wpn->Misc[__EWI_MOVEMENT]==EWM_SINE_WAVE)
                {
                    // For sine waves, adjust the weapon's position at an angle
                    // perpendicular to that of its natural movement.
                    float offset;
                    wpn->Misc[__EWI_WORK]+=15;
                    offset=wpn->Misc[__EWI_MOVEMENT_ARG]*Sin(wpn->Misc[__EWI_WORK]);
                    wpn->Misc[__EWI_XPOS]+=(wpn->Step/100)*RadianCos(wpn->Angle);
                    wpn->Misc[__EWI_YPOS]+=(wpn->Step/100)*RadianSin(wpn->Angle);
                    wpn->X=wpn->Misc[__EWI_XPOS]+offset*RadianCos(wpn->Angle+1.5708);
                    wpn->Y=wpn->Misc[__EWI_YPOS]+offset*RadianSin(wpn->Angle+1.5708);
                }

                // Fast sine wave
                else if(wpn->Misc[__EWI_MOVEMENT]==EWM_SINE_WAVE_FAST)
                {
                    float offset;
                    wpn->Misc[__EWI_WORK]+=36;
                    offset=wpn->Misc[__EWI_MOVEMENT_ARG]*Sin(wpn->Misc[__EWI_WORK]);
                    wpn->Misc[__EWI_XPOS]+=(wpn->Step/100)*RadianCos(wpn->Angle);
                    wpn->Misc[__EWI_YPOS]+=(wpn->Step/100)*RadianSin(wpn->Angle);
                    wpn->X=wpn->Misc[__EWI_XPOS]+offset*RadianCos(wpn->Angle+1.5708);
                    wpn->Y=wpn->Misc[__EWI_YPOS]+offset*RadianSin(wpn->Angle+1.5708);
                }

                // Homing
                else if(wpn->Misc[__EWI_MOVEMENT]==EWM_HOMING)
                {
                    // Wrap angle to 0..2*PI
                    float angle1=wpn->Angle%6.2832;

                    if(angle1<0)
                        angle1+=6.2832;

                    // Find angle to Link and wrap it
                    float angle2=RadianAngle(wpn->X, wpn->Y, Link->X, Link->Y);
                    if(angle2<0)
                        angle2+=6.2832;

                    float diff=Abs(angle1-angle2);

                    // Turn toward Link
                    if(diff<wpn->Misc[__EWI_MOVEMENT_ARG] || diff>6.2832-wpn->Misc[__EWI_MOVEMENT_ARG])
                        wpn->Angle=angle2;
                    
                    // Can't turn enough to point directly at him...
                    else if(Sign(angle1-angle2)==Sign(diff-PI)) // if angle1>angle2 and diff>pi or angle1<angle2 and diff<pi
                        wpn->Angle+=wpn->Misc[__EWI_MOVEMENT_ARG];
                    else
                        wpn->Angle-=wpn->Misc[__EWI_MOVEMENT_ARG];

                    SetEWeaponDir(wpn);
                }

                // Homing, stopping to re-aim
                else if(wpn->Misc[__EWI_MOVEMENT]==EWM_HOMING_REAIM)
                {
                    if(wpn->Misc[__EWI_WORK]==0)
                        wpn->Misc[__EWI_WORK]=45;

                    if(wpn->Misc[__EWI_WORK]>0) // If positive, wpn is moving

                    {

                        wpn->Misc[__EWI_WORK]--;
                        if(wpn->Misc[__EWI_WORK]==0)
                        {
                            if(wpn->Misc[__EWI_MOVEMENT_ARG]<=0) // No more aims left
                                KillEWeapon(wpn);

                            else // Stop
                            {
                                wpn->Misc[__EWI_MOVEMENT_ARG]--;
                                wpn->Step=0;
                                wpn->Misc[__EWI_WORK]=-20;
                            }
                        }
                    }
                    else // If negative, it's stopped to aim
                    {
                        wpn->Misc[__EWI_WORK]++;
                        if(wpn->Misc[__EWI_WORK]==0) // Start up again
                        {
                            wpn->Misc[__EWI_WORK]=45;
                            wpn->Angle=RadianAngle(wpn->X, wpn->Y, Link->X, Link->Y);
                            wpn->Step=wpn->Misc[__EWI_WORK_2];
                            SetEWeaponDir(wpn);
                            if((wpn->Misc[__EWI_FLAGS]&EWF_ROTATE)!=0)
                                SetEWeaponRotation(wpn);
                        }
                        // Spin in place while waiting
                        else if((wpn->Misc[__EWI_FLAGS]&EWF_ROTATE)!=0)
                        {
                            // Pick the direction based on the timer
                            int dir=-wpn->Misc[__EWI_WORK]&110b;
                            
                            if(dir==110b)
                                SetEWeaponRotation(wpn, DIR_UP);
                            else if(dir==100b)
                                SetEWeaponRotation(wpn, DIR_RIGHT);
                            else if(dir==010b)
                                SetEWeaponRotation(wpn, DIR_DOWN);
                            else
                                SetEWeaponRotation(wpn, DIR_LEFT);
                        }
                    }
                }
                
                // Random
                else if(wpn->Misc[__EWI_MOVEMENT]==EWM_RANDOM)
                {
                    wpn->Angle+=Randf(2*wpn->Misc[__EWI_MOVEMENT_ARG])-wpn->Misc[__EWI_MOVEMENT_ARG];
                    SetEWeaponDir(wpn);
                    if((wpn->Misc[__EWI_FLAGS]&EWF_ROTATE)!=0)
                        SetEWeaponRotation(wpn);
                }

                // Random, stopping to re-aim
                else if(wpn->Misc[__EWI_MOVEMENT]==EWM_RANDOM_REAIM)
                {
                    if(wpn->Misc[__EWI_WORK]==0)
                        wpn->Misc[__EWI_WORK]=45;

                    if(wpn->Misc[__EWI_WORK]>0) // If positive, wpn is moving
                    {
                        wpn->Misc[__EWI_WORK]--;
                        if(wpn->Misc[__EWI_WORK]==0)
                        {
                            if(wpn->Misc[__EWI_MOVEMENT_ARG]<=0) // No more aims left
                                KillEWeapon(wpn);
                            else // Stop
                            {
                                wpn->Misc[__EWI_MOVEMENT_ARG]--;
                                wpn->Step=0;
                                wpn->Misc[__EWI_WORK]=-20;
                            }
                        }

                    }
                    else // If negative, it's stopped to aim
                    {
                        wpn->Misc[__EWI_WORK]++;
                        if(wpn->Misc[__EWI_WORK]==0) // Start up again
                        {
                            wpn->Misc[__EWI_WORK]=45;
                            wpn->Angle=Rand(31416)/5000;
                            wpn->Step=wpn->Misc[__EWI_WORK_2];
                            SetEWeaponDir(wpn);
                            if((wpn->Misc[__EWI_FLAGS]&EWF_ROTATE)!=0)
                                SetEWeaponRotation(wpn);
                        }
                        // Spin in place while waiting
                        else if((wpn->Misc[__EWI_FLAGS]&EWF_ROTATE)!=0)
                        {
                            // Pick the direction based on the timer
                            int dir=-wpn->Misc[__EWI_WORK]&110b;
                            
                            if(dir==110b)
                                SetEWeaponRotation(wpn, DIR_UP);
                            else if(dir==100b)
                                SetEWeaponRotation(wpn, DIR_RIGHT);
                            else if(dir==010b)
                                SetEWeaponRotation(wpn, DIR_DOWN);
                            else
                                SetEWeaponRotation(wpn, DIR_LEFT);
                        }
                    }
                }

                // Veering
                else
                {
                    // Override regular movement
                    int dir=wpn->Misc[__EWI_MOVEMENT]-EWM_VEER;
                    wpn->Misc[__EWI_XPOS]+=(wpn->Step/100)*RadianCos(wpn->Angle);
                    wpn->Misc[__EWI_YPOS]+=(wpn->Step/100)*RadianSin(wpn->Angle);
                    
                    if(dir==DIR_UP)
                        wpn->Misc[__EWI_YPOS]-=wpn->Misc[__EWI_WORK];
                    else if(dir==DIR_DOWN)
                        wpn->Misc[__EWI_YPOS]+=wpn->Misc[__EWI_WORK];
                    else if(dir==DIR_LEFT)
                        wpn->Misc[__EWI_XPOS]-=wpn->Misc[__EWI_WORK];
                    else if(dir==DIR_RIGHT)
                        wpn->Misc[__EWI_XPOS]+=wpn->Misc[__EWI_WORK];
                    else if(dir==DIR_LEFTUP)
                    {
                        wpn->Misc[__EWI_XPOS]-=wpn->Misc[__EWI_WORK]*0.7071;
                        wpn->Misc[__EWI_YPOS]-=wpn->Misc[__EWI_WORK]*0.7071;
                    }
                    else if(dir==DIR_RIGHTUP)
                    {
                        wpn->Misc[__EWI_XPOS]+=wpn->Misc[__EWI_WORK]*0.7071;
                        wpn->Misc[__EWI_YPOS]-=wpn->Misc[__EWI_WORK]*0.7071;
                    }
                    else if(dir==DIR_LEFTDOWN)
                    {
                        wpn->Misc[__EWI_XPOS]-=wpn->Misc[__EWI_WORK]*0.7071;
                        wpn->Misc[__EWI_YPOS]+=wpn->Misc[__EWI_WORK]*0.7071;
                    }
                    else // DIR_RIGHTDOWN
                    {
                        wpn->Misc[__EWI_XPOS]+=wpn->Misc[__EWI_WORK]*0.7071;
                        wpn->Misc[__EWI_YPOS]+=wpn->Misc[__EWI_WORK]*0.7071;
                    }

                    wpn->X=wpn->Misc[__EWI_XPOS];
                    wpn->Y=wpn->Misc[__EWI_YPOS];
                    wpn->Misc[__EWI_WORK]+=wpn->Misc[__EWI_MOVEMENT_ARG];
                }
            }
            else // wpn->Misc[__EWI_MOVEMENT]>=15
            {
                // Throw
                if(wpn->Misc[__EWI_MOVEMENT]>=EWM_THROW && wpn->Misc[__EWI_MOVEMENT]<=EWM_THROW_BOUNCE_STOP)
                {
                    // __EWI_WORK: Jump
                    // __EWI_WORK_2: Z position
                    // __EWI_MOVEMENT_ARG: Initial jump

                    wpn->Jump=0; // Override engine handling of Z movement

                    // Just thrown
                    if(wpn->Misc[__EWI_WORK]==0 && wpn->Misc[__EWI_MOVEMENT_ARG]!=0)
                    {
                        wpn->Misc[__EWI_WORK]=wpn->Misc[__EWI_MOVEMENT_ARG];
                        wpn->Misc[__EWI_MOVEMENT_ARG]=0;
                    }

                    // Fall
                    wpn->Misc[__EWI_WORK_2]=Max(wpn->Misc[__EWI_WORK_2]+wpn->Misc[__EWI_WORK], 0);
                    wpn->Z=wpn->Misc[__EWI_WORK_2];

                    // Hit the ground
                    if(wpn->Misc[__EWI_WORK_2]==0)
                    {
                        // No bounce
                        if(wpn->Misc[__EWI_MOVEMENT]==EWM_THROW)
                            KillEWeapon(wpn);
                        else if(wpn->Misc[__EWI_MOVEMENT]==EWM_THROW_STOP)
                        {
                            wpn->Misc[__EWI_MOVEMENT]=0;
                            wpn->Step=0;
                        }

                        // Bounce
                        else
                        {
                            if(wpn->Misc[__EWI_WORK]<-0.5)
                            {
                                wpn->Misc[__EWI_WORK]*=-0.5;
                                wpn->Step*=0.75;
                            }

                            // Not falling fast enough
                            else if(wpn->Misc[__EWI_MOVEMENT]==EWM_THROW_BOUNCE)
                                KillEWeapon(wpn);
                            else // EWM_THROW_BOUNCE_STOP
                            {
                                wpn->Misc[__EWI_MOVEMENT]=0;
                                wpn->Step=0;
                            }
                        }
                    }

                    // Still in the air; adjust velocity
                    else
                        wpn->Misc[__EWI_WORK]=Max(wpn->Misc[__EWI_WORK]-GH_GRAVITY, -GH_TERMINAL_VELOCITY);
                }

                // Fall
                else if(wpn->Misc[__EWI_MOVEMENT]==EWM_FALL)
                {
                    wpn->Jump=0; // Override engine handling of Z movement
                    wpn->Z-=wpn->Misc[__EWI_WORK];
                    wpn->Misc[__EWI_WORK]=Min(wpn->Misc[__EWI_WORK]+GH_GRAVITY, GH_TERMINAL_VELOCITY);

                    if(wpn->Z+wpn->Jump<=0)
                    {
                        wpn->Z=0;
                        KillEWeapon(wpn);
                    }
                }
                
                // Drift
                else if(wpn->Misc[__EWI_MOVEMENT]>=EWM_DRIFT && wpn->Misc[__EWI_MOVEMENT]<EWM_DRIFT_WAIT+8)
                {
                    int dir;
                    
                    // EWM_DRIFT
                    if(wpn->Misc[__EWI_MOVEMENT]<EWM_DRIFT_WAIT)
                    {
                        dir=wpn->Misc[__EWI_MOVEMENT]-EWM_DRIFT;
                        
                        // Override regular movement
                        if(wpn->Misc[__EWI_WORK]>=16)
                        {
                            wpn->Misc[__EWI_XPOS]+=(wpn->Step/100)*RadianCos(wpn->Angle);
                            wpn->Misc[__EWI_YPOS]+=(wpn->Step/100)*RadianSin(wpn->Angle);
                        }
                    }
                    
                    // EWM_DRIFT_WAIT
                    else
                    {
                        dir=wpn->Misc[__EWI_MOVEMENT]-EWM_DRIFT_WAIT;
                        
                        // Is the weapon moving? Override its regular movement if so
                        if(wpn->Misc[__EWI_WORK]>=16)
                        {
                            wpn->Misc[__EWI_XPOS]+=(wpn->Step/100)*RadianCos(wpn->Angle);
                            wpn->Misc[__EWI_YPOS]+=(wpn->Step/100)*RadianSin(wpn->Angle);
                        }
                        
                        // If not, just drift in place
                        else
                            wpn->Misc[__EWI_WORK]++;
                    }
                    
                    // Drifting
                    if(dir==DIR_UP)
                        wpn->Misc[__EWI_YPOS]-=wpn->Misc[__EWI_MOVEMENT_ARG];
                    else if(dir==DIR_DOWN)
                        wpn->Misc[__EWI_YPOS]+=wpn->Misc[__EWI_MOVEMENT_ARG];
                    else if(dir==DIR_LEFT)
                        wpn->Misc[__EWI_XPOS]-=wpn->Misc[__EWI_MOVEMENT_ARG];
                    else if(dir==DIR_RIGHT)
                        wpn->Misc[__EWI_XPOS]+=wpn->Misc[__EWI_MOVEMENT_ARG];
                    else if(dir==DIR_LEFTUP)
                    {
                        wpn->Misc[__EWI_XPOS]-=wpn->Misc[__EWI_MOVEMENT_ARG]*0.7071;
                        wpn->Misc[__EWI_YPOS]-=wpn->Misc[__EWI_MOVEMENT_ARG]*0.7071;
                    }
                    else if(dir==DIR_RIGHTUP)
                    {
                        wpn->Misc[__EWI_XPOS]+=wpn->Misc[__EWI_MOVEMENT_ARG]*0.7071;
                        wpn->Misc[__EWI_YPOS]-=wpn->Misc[__EWI_MOVEMENT_ARG]*0.7071;
                    }
                    else if(dir==DIR_LEFTDOWN)
                    {
                        wpn->Misc[__EWI_XPOS]-=wpn->Misc[__EWI_MOVEMENT_ARG]*0.7071;
                        wpn->Misc[__EWI_YPOS]+=wpn->Misc[__EWI_MOVEMENT_ARG]*0.7071;
                    }
                    else // DIR_RIGHTDOWN
                    {
                        wpn->Misc[__EWI_XPOS]+=wpn->Misc[__EWI_MOVEMENT_ARG]*0.7071;
                        wpn->Misc[__EWI_YPOS]+=wpn->Misc[__EWI_MOVEMENT_ARG]*0.7071;
                    }
                    
                    wpn->X=wpn->Misc[__EWI_XPOS];
                    wpn->Y=wpn->Misc[__EWI_YPOS];
                }
            }
        } // End movement updates
        
        
        // Start lifespan updates
        if(wpn->Misc[__EWI_LIFESPAN]!=0)
        {
            if(wpn->Misc[__EWI_LIFESPAN]==EWL_TIMER)
            {
                wpn->Misc[__EWI_LIFESPAN_ARG]-=1;
                if(wpn->Misc[__EWI_LIFESPAN_ARG]<=0)
                    KillEWeapon(wpn);
            }
            else if(wpn->Misc[__EWI_LIFESPAN]==EWL_NEAR_LINK)
            {
                if(Distance(wpn->X, wpn->Y, Link->X, Link->Y)<wpn->Misc[__EWI_LIFESPAN_ARG])
                    KillEWeapon(wpn);
            }
            else if(wpn->Misc[__EWI_LIFESPAN]==EWL_SLOW_TO_HALT)
            {
                wpn->Step=Max(0, wpn->Step-wpn->Misc[__EWI_LIFESPAN_ARG]);
                if(wpn->Step<=0)
                    KillEWeapon(wpn);
            }
        } // End lifespan updates
    }

    // Start death effects
    else if(wpn->Misc[__EWI_ON_DEATH]!=0 && (wpn->Misc[__EWI_FLAGS]&__EWFI_DEATH_EFFECT_DONE)==0)
    {
        if(wpn->Misc[__EWI_ON_DEATH]<0)
        {
            int id;
            eweapon prototype;
            eweapon newWpn;
            int spreadType;
            int centerX;
            int centerY;
            float angle;
            int numShots;
            int i;

            // Find the prototype
            id=Floor(wpn->Misc[__EWI_ON_DEATH]);
            for(i=Screen->NumEWeapons(); i>0; i--)
            {
                prototype=Screen->LoadEWeapon(i);
                if((prototype->Misc[__EWI_FLAGS]&__EWFI_DUMMY_CHECK)!=__EWFI_DUMMY_CHECK)
                    continue;

                // It's a dummy; check the ID
                if(prototype->Misc[__EWI_ID]==id)
                    break;
            }

            // Didn't find it? Print an error, remove the weapon, and return
            if(i==0)
            {
                int error[]="ghost.zh: Failed to find prototype eweapon";
                TraceS(error);
                TraceNL();
                wpn->DeadState=0;
                return;
            }

            angle=wpn->Misc[__EWI_ON_DEATH_ARG]%10-6.2832;
            numShots=(wpn->Misc[__EWI_ON_DEATH]-id)*10000;
            spreadType=((wpn->Misc[__EWI_ON_DEATH_ARG]-angle)/100)>>0;

            if(wpn->Extend==3)
            {
                centerX=wpn->X+8*wpn->TileWidth;
                centerY=wpn->Y+8*wpn->TileHeight;
            }
            else
            {
                centerX=wpn->X+8;
                centerY=wpn->Y+8;
            }

            // Got the data; create some weapons

            // Evenly spaced
            if(spreadType==EWD_EVEN)
            {
                for(float i=0; i<numShots; i++)
                    __CopyEWeapon(prototype, centerX, centerY, angle+6.2832*i/numShots);
                Game->PlaySound(prototype->Misc[__EWI_DUMMY_SOUND]);
            }

            // Random angles
            else if(spreadType==EWD_RANDOM)
            {
                for(int i=0; i<numShots; i++)
                    __CopyEWeapon(prototype, centerX, centerY, Rand(31416)/5000);
                Game->PlaySound(prototype->Misc[__EWI_DUMMY_SOUND]);
            }

            // Aimed at Link
            else // EWD_AIMED
            {
                if(numShots>1)
                {
                    float startAngle=ArcTan(Link->X+8-centerX, Link->Y+8-centerY)-angle/2;
                    for(int i=0; i<numShots; i++)
                        __CopyEWeapon(prototype, centerX, centerY, startAngle+angle*i/(numShots-1));
                }
                else if(numShots==1)
                    __CopyEWeapon(prototype, centerX, centerY, ArcTan(Link->X+8-centerX, Link->Y+8-centerY));

                Game->PlaySound(prototype->Misc[__EWI_DUMMY_SOUND]);
            }

            wpn->DeadState=0;

        }

        // Split in half to reduce checks
        else if(wpn->Misc[__EWI_ON_DEATH]<8)
        {
            // Vanish
            if(wpn->Misc[__EWI_ON_DEATH]==EWD_VANISH)
                wpn->DeadState=0;

            // Aim at Link
            else if(wpn->Misc[__EWI_ON_DEATH]==EWD_AIM_AT_LINK)
            {
                wpn->Step=0;
                wpn->Misc[__EWI_ON_DEATH_ARG]-=1;
                if(wpn->Misc[__EWI_ON_DEATH_ARG]<=0)
                {
                    wpn->Angle=RadianAngle(wpn->X, wpn->Y, Link->X, Link->Y);
                    SetEWeaponDir(wpn);
                    SetEWeaponRotation(wpn);
                    wpn->Step=300;
                    wpn->Misc[__EWI_ON_DEATH]=0;
                }
                // Spin while waiting
                else if((wpn->Misc[__EWI_FLAGS]&EWF_ROTATE)!=0)
                {
                    // Pick a direction based on the counter
                    int dir=wpn->Misc[__EWI_ON_DEATH_ARG]&110b;
                    if(dir==110b)
                        SetEWeaponRotation(wpn, DIR_UP);
                    else if(dir==100b)
                        SetEWeaponRotation(wpn, DIR_RIGHT);
                    else if(dir==010b)
                        SetEWeaponRotation(wpn, DIR_DOWN);
                    else
                        SetEWeaponRotation(wpn, DIR_LEFT);
                }
            }

            // Explode
            else if(wpn->Misc[__EWI_ON_DEATH]==EWD_EXPLODE)
            {
                FireNonAngularEWeapon(EW_BOMBBLAST, CenterX(wpn)-8, CenterY(wpn)-8, wpn->Dir, 0, wpn->Misc[__EWI_ON_DEATH_ARG], -1, 0, 0);
                wpn->DeadState=0;
            }


            // Super explode
            else if(wpn->Misc[__EWI_ON_DEATH]==EWD_SBOMB_EXPLODE)
            {
                FireNonAngularEWeapon(EW_SBOMBBLAST, CenterX(wpn)-8, CenterY(wpn)-8, wpn->Dir, 0, wpn->Misc[__EWI_ON_DEATH_ARG], -1, 0, 0);
                wpn->DeadState=0;
            }

            // 4 fireballs, UDLR
            else if(wpn->Misc[__EWI_ON_DEATH]==EWD_4_FIREBALLS_HV)
            {
                for(int i=0; i<4; i++)
                    FireNonAngularEWeapon(EW_FIREBALL, CenterX(wpn)-8, CenterY(wpn)-8, i, 200, wpn->Damage/2, wpn->Misc[__EWI_ON_DEATH_ARG], 0, 0);
                wpn->DeadState=0;
            }

            // 4 fireballs, diagonal
            else if(wpn->Misc[__EWI_ON_DEATH]==EWD_4_FIREBALLS_DIAG)
            {
                for(int i=4; i<8; i++)
                    FireNonAngularEWeapon(EW_FIREBALL, CenterX(wpn)-8, CenterY(wpn)-8, i, 200, wpn->Damage/2, wpn->Misc[__EWI_ON_DEATH_ARG], 0, 0);
                wpn->DeadState=0;
            }

            // 4 fireballs, random
            else if(wpn->Misc[__EWI_ON_DEATH]==EWD_4_FIREBALLS_RANDOM)
            {
                if(Rand(2)==0)
                {
                    for(int i=0; i<4; i++)
                        FireNonAngularEWeapon(EW_FIREBALL, CenterX(wpn)-8, CenterY(wpn)-8, i, 200, wpn->Damage/2, wpn->Misc[__EWI_ON_DEATH_ARG], 0, 0);
                }
                else
                {
                    for(int i=4; i<8; i++)
                        FireNonAngularEWeapon(EW_FIREBALL, CenterX(wpn)-8, CenterY(wpn)-8, i, 200, wpn->Damage/2, wpn->Misc[__EWI_ON_DEATH_ARG], 0, 0);
                }
                wpn->DeadState=0;
            }
        }
        else // wpn->Misc[__EWI_ON_DEATH]>=8
        {
            // 8 fireballs
            if(wpn->Misc[__EWI_ON_DEATH]==EWD_8_FIREBALLS)
            {
                for(int i=0; i<8; i++)
                    FireNonAngularEWeapon(EW_FIREBALL, CenterX(wpn)-8, CenterY(wpn)-8, i, 200, wpn->Damage/2, wpn->Misc[__EWI_ON_DEATH_ARG], 0, 0);
                wpn->DeadState=0;
            }

            // 4 fires, UDLR
            else if(wpn->Misc[__EWI_ON_DEATH]==EWD_4_FIRES_HV)
            {
                for(int i=0; i<4; i++)
                    FireNonAngularEWeapon(EW_FIRE, CenterX(wpn)-8, CenterY(wpn)-8, i, 100, wpn->Damage/2, wpn->Misc[__EWI_ON_DEATH_ARG], 0, 0);
                Game->PlaySound(SFX_FIRE); // Only play sound once
                wpn->DeadState=0;
            }

            // 4 fires, diagonal
            else if(wpn->Misc[__EWI_ON_DEATH]==EWD_4_FIRES_DIAG)
            {
                for(int i=4; i<8; i++)
                    FireNonAngularEWeapon(EW_FIRE, CenterX(wpn)-8, CenterY(wpn)-8, i, 71, wpn->Damage/2, wpn->Misc[__EWI_ON_DEATH_ARG], 0, 0);
                Game->PlaySound(SFX_FIRE);
                wpn->DeadState=0;
            }

            // 4 fires, random
            else if(wpn->Misc[__EWI_ON_DEATH]==EWD_4_FIRES_RANDOM)
            {
                if(Rand(2)==0)
                {
                    for(int i=0; i<4; i++)
                        FireNonAngularEWeapon(EW_FIRE, CenterX(wpn)-8, CenterY(wpn)-8, i, 100, wpn->Damage/2, wpn->Misc[__EWI_ON_DEATH_ARG], 0, 0);
                }
                else
                {
                    for(int i=4; i<8; i++)
                        FireNonAngularEWeapon(EW_FIRE, CenterX(wpn)-8, CenterY(wpn)-8, i, 71, wpn->Damage/2, wpn->Misc[__EWI_ON_DEATH_ARG], 0, 0);
                }

                Game->PlaySound(SFX_FIRE);
                wpn->DeadState=0;
            }

            // 8 fires
            else if(wpn->Misc[__EWI_ON_DEATH]==EWD_8_FIRES)
            {
                for(int i=0; i<4; i++)
                    FireNonAngularEWeapon(EW_FIRE, CenterX(wpn)-8, CenterY(wpn)-8, i, 100, wpn->Damage/2, wpn->Misc[__EWI_ON_DEATH_ARG], 0, 0);
                for(int i=4; i<8; i++)
                    FireNonAngularEWeapon(EW_FIRE, CenterX(wpn)-8, CenterY(wpn)-8, i, 71, wpn->Damage/2, wpn->Misc[__EWI_ON_DEATH_ARG], 0, 0);
                Game->PlaySound(SFX_FIRE);
                wpn->DeadState=0;
            }

            // Spawn npc
            else if(wpn->Misc[__EWI_ON_DEATH]==EWD_SPAWN_NPC)
            {
                npc enemy=Screen->CreateNPC(wpn->Misc[__EWI_ON_DEATH_ARG]);
                enemy->X=wpn->X;
                enemy->Y=wpn->Y;
                wpn->DeadState=0;
            }


            // Single fire
            else if(wpn->Misc[__EWI_ON_DEATH]==EWD_FIRE)
            {
                FireNonAngularEWeapon(EW_FIRE, CenterX(wpn)-8, CenterY(wpn)-8, wpn->Dir, 0, wpn->Damage/2, wpn->Misc[__EWI_ON_DEATH_ARG], 0, 0);
                Game->PlaySound(SFX_FIRE);
                wpn->DeadState=0;
            }

            // Run FFC script
            else if(wpn->Misc[__EWI_ON_DEATH]==EWD_RUN_SCRIPT)
            {

                int ffcID;
                ffc f;
                eweapon checkWpn;
                int minID;

                // First, find a free FFC
                ffcID=FindUnusedFFC();
                if(ffcID==0)
                {
                    // None available; just remove the weapon
                    wpn->DeadState=0;
                    return;
                }
                f=Screen->LoadFFC(ffcID);

                // Give the weapon an ID number so it can be found later
                for(int i=Screen->NumEWeapons(); i>0; i--)
                {
                    checkWpn=Screen->LoadEWeapon(i);
                    if((checkWpn->Misc[__EWI_FLAGS]&__EWFI_DUMMY_CHECK)!=__EWFI_IS_GHZH_EWPN) // Filter out dummies
                        continue;

                    minID=Min(minID, checkWpn->Misc[__EWI_ID]);
                }
                wpn->Misc[__EWI_ID]=minID-1;

                // Set the death effect done flag so this doesn't repeat every frame
                wpn->Misc[__EWI_FLAGS]|=__EWFI_DEATH_EFFECT_DONE;

                // Then run the script
                f->Data=GH_INVISIBLE_COMBO;
                f->X=CenterX(wpn)-8;
                f->Y=CenterY(wpn)-8;
                f->Script=wpn->Misc[__EWI_ON_DEATH_ARG];
                f->InitD[0]=minID-1;
            }
        }
    } // End death effects
}

// Calls UpdateEWeapon() on every weapon on the screen
void UpdateEWeapons()
{
    // If Link's holding up an item, don't do anything
    if(Link->Action==LA_HOLD1LAND || Link->Action==LA_HOLD2LAND ||
       Link->Action==LA_HOLD1WATER || Link->Action==LA_HOLD2WATER)
        return;
    
    eweapon wpn;

    for(int i=Screen->NumEWeapons(); i>0; i--)
    {
        wpn=Screen->LoadEWeapon(i);
        
        // If this is a dummy, or if it's not a ghost.zh weapon, don't do anything
        if((wpn->Misc[__EWI_FLAGS]&__EWFI_IS_GHZH_EWPN)==0 ||
           (wpn->Misc[__EWI_FLAGS]&__EWFI_DUMMY)!=0)
            continue;

    
        UpdateEWeapon(wpn);
    }
}

// Set the weapon's direction based on its angle
void SetEWeaponDir(eweapon wpn)
{
    float angle=wpn->Angle%6.2832;
    if(angle<0)
        angle+=6.2832;

    if(angle<0.3927 || angle>5.8905)
        wpn->Dir=DIR_RIGHT;
    else if(angle<1.1781)
        wpn->Dir=DIR_RIGHTDOWN;
    else if(angle<1.9635)
        wpn->Dir=DIR_DOWN;
    else if(angle<2.7489)
        wpn->Dir=DIR_LEFTDOWN;
    else if(angle<3.5343)
        wpn->Dir=DIR_LEFT;
    else if(angle<4.3197)
        wpn->Dir=DIR_LEFTUP;
    else if(angle<5.1051)
        wpn->Dir=DIR_UP;
    else
        wpn->Dir=DIR_RIGHTUP;
}

// Flip the weapon's sprite to match its direction
void SetEWeaponRotation(eweapon wpn)
{
    if(wpn->Angular)
    {
        float angle=wpn->Angle%6.2832;
        if(angle<0)
            angle+=6.2832;

        if(angle<0.7854 || angle>5.4978) // Right
            wpn->Flip=4;
        else if(angle<=2.3562) // Down
            wpn->Flip=3;
        else if(angle<3.927) // Left
            wpn->Flip=7;
        else // Up
            wpn->Flip=0;
    }
    else
    {
        if(wpn->Dir==DIR_UP || wpn->Dir==DIR_RIGHTUP || wpn->Dir==DIR_LEFTUP)
            wpn->Flip=0;
        else if(wpn->Dir==DIR_DOWN || wpn->Dir==DIR_RIGHTDOWN || wpn->Dir==DIR_LEFTDOWN)
            wpn->Flip=3;
        else if(wpn->Dir==DIR_LEFT)
            wpn->Flip=7;
        else // Right
            wpn->Flip=4;
    }
}

// Flip the weapon's sprite to match the given direction
void SetEWeaponRotation(eweapon wpn, int direction)
{
    if(direction==DIR_UP || direction==DIR_RIGHTUP || direction==DIR_LEFTUP)
        wpn->Flip=0;
    else if(direction==DIR_DOWN || direction==DIR_RIGHTDOWN || direction==DIR_LEFTDOWN)
        wpn->Flip=3;
    else if(direction==DIR_LEFT)
        wpn->Flip=7;
    else // Right
        wpn->Flip=4;
}

// Kill an eweapon, triggering any death effects
void KillEWeapon(eweapon wpn)
{
    wpn->Misc[__EWI_FLAGS]|=__EWFI_DEAD;
}

// Draw a shadow under an eweapon
void DrawEWeaponShadow(eweapon wpn)
{
    int x=CenterX(wpn)-8+wpn->DrawXOffset;
    int y=wpn->Y+(wpn->TileHeight-1)*16+wpn->DrawYOffset;

    if(GH_SHADOW_TRANSLUCENT>0)
        Screen->DrawTile(1, x, y, GH_SHADOW_TILE, 1, 1, GH_SHADOW_CSET, -1, -1, 0, 0, 0, 0, true, 64);
    else
        Screen->DrawTile(1, x, y, GH_SHADOW_TILE, 1, 1, GH_SHADOW_CSET, -1, -1, 0, 0, 0, 0, true, 128);
}

// Get the standard sprite for this weapon type
int GetDefaultEWeaponSprite(int weaponID)
{
    if(weaponID==EW_FIREBALL || weaponID==EW_FIREBALL)
        return 17;
    else if(weaponID==EW_ROCK)
        return 18;
    else if(weaponID==EW_ARROW)
        return 19;
    else if(weaponID==EW_FIRE)
        return 35;
    else if(weaponID==EW_FIRE2)
        return 81;
    else if(weaponID==EW_FIRETRAIL)
        return 80;
    else if(weaponID==EW_MAGIC)
        return 21;
    else if(weaponID==EW_BEAM)
        return 20;
    else if(weaponID==EW_WIND)
        return 36;
    else if(weaponID==EW_BOMB)
        return 76;
    else if(weaponID==EW_SBOMB)
        return 77;
    else if(weaponID==EW_BRANG)
    {
        // The sprite depends on what boomerang Link has, so check his inventory
        int maxLevel=0;
        itemdata id;

        for(int i=0; i<256; i++)
        {
            if(!Link->Item[i])
                continue;

            id=Game->LoadItemData(i);

            if(id->Family!=IC_BRANG)
                continue;

            if(id->Level>maxLevel)
            {
                maxLevel=id->Level;
                if(maxLevel>=3) // Any higher won't matter
                    break;
            }

        }

        if(maxLevel<=1)
            return 4;
        else if(maxLevel==2)
            return 5;
        else
            return 6;
    }
    else
        return 0;
}

// Find the sound normally made by weapons of this type
int GetDefaultEWeaponSound(int weaponID)
{
     if(weaponID==EW_FIREBALL || weaponID==EW_FIREBALL2)
        return 40;
    else if(weaponID==EW_MAGIC || weaponID==EW_WIND)
        return 32;
    else if(weaponID==EW_FIRE || weaponID==EW_FIRE2 || weaponID==EW_FIRETRAIL)
        return 13;
    else if(weaponID==EW_ROCK)
        return 51;
    else
        return 0;
}

// Use this in a script started on eweapon death to find the weapon that created it
eweapon GetAssociatedEWeapon(int weaponID)
{
    eweapon wpn;
    
    for(int i=Screen->NumEWeapons(); i>0; i--)
    {
        wpn=Screen->LoadEWeapon(i);
        if((wpn->Misc[__EWI_FLAGS]&__EWFI_DUMMY_CHECK)!=__EWFI_IS_GHZH_EWPN) // Filter out dummies
            continue;

        if(wpn->Misc[__EWI_ID]==weaponID)
            return wpn;
    }
    
    // Couldn't find it; return an uninitialized weapon
    eweapon invalidWpn;
    return invalidWpn;
}

// Is this a ghost.zh-controlled weapon?
bool IsGhostZHEWeapon(eweapon wpn)
{
    return (wpn->Misc[__EWI_FLAGS]&__EWFI_IS_GHZH_EWPN)!=0;
}

// Is htis a dummy weapon?
bool IsDummyEWeapon(eweapon wpn)
{
    return (wpn->Misc[__EWI_FLAGS]&__EWFI_DUMMY_CHECK)==__EWFI_DUMMY_CHECK;
}


// ===============
// |||| CLOCK ||||
// ===============

void StartClock()

{
    __ghzhClockTimer=0;
}

void UpdateClock()
{
    int screen=(Game->GetCurDMap()<<8)+Game->GetCurDMapScreen();

    if(__ghzhPrevScreen!=screen) // Changed screens, end clock
    {
        __ghzhClockTimer=0;
        __ghzhPrevScreen=screen;
    }
    else if(__ghzhClockTimer>0)
        __ghzhClockTimer--;
}

bool ClockIsActive()
{
    return __ghzhClockTimer!=0;
}


// ============================
// |||| INTERNAL FUNCTIONS ||||
// ============================

// Before waiting: Update direction, set combo, set overlay flag, draw shadow
void __Ghost_WaitframePart1(ffc this, npc ghost, bool useNPCDir)
{

    // Direction forced - set the npc's direction and unset the flag
    if((__Ghost_InternalFlags&__GHFI_DIR_FORCED)!=0)
        ghost->Dir=Ghost_Dir;

    // Use npc's direction
    else if(useNPCDir)
        Ghost_Dir=ghost->Dir;

    // Set direction based on movement
    else if(Ghost_FlagIsSet(GHF_SET_DIRECTION) && (__Ghost_PrevX!=Ghost_X || __Ghost_PrevY!=Ghost_Y))
    {
        float xStep=Ghost_X-__Ghost_PrevX;
        float yStep=Ghost_Y-__Ghost_PrevY;

        // Use 8 directions if 8-way flag is set
        if(Ghost_FlagIsSet(GHF_8WAY))
            Ghost_Dir=AngleDir8(WrapAngle(ArcTan(xStep, yStep))*57.2958);


        // Otherwise, 4 directions
        else
        {
            if(Abs(xStep)>Abs(yStep))
            {
                if(xStep<0)
                    Ghost_Dir=DIR_LEFT;
                else
                    Ghost_Dir=DIR_RIGHT;
            }
            else
            {
                if(yStep<0)
                    Ghost_Dir=DIR_UP;
                else
                    Ghost_Dir=DIR_DOWN;
            }
        }
    }
    
    ghost->Dir=Ghost_Dir;
    __Ghost_PrevX=Ghost_X;
    __Ghost_PrevY=Ghost_Y;
    
    // Set combo
    if(Ghost_Data==0 || Ghost_Data==GH_INVISIBLE_COMBO)
    {
        if(this->Data!=Ghost_Data)
            this->Data=Ghost_Data;
    }
    else
    {
        if(Ghost_FlagIsSet(GHF_8WAY))
        {
            if(this->Data!=Ghost_Data+Ghost_Dir)
                this->Data=Ghost_Data+VBound(Ghost_Dir, 7, 0);
        }
        else if(Ghost_FlagIsSet(GHF_4WAY))
        {
            if(this->Data!=Ghost_Data+Ghost_Dir)
                this->Data=Ghost_Data+VBound(Ghost_Dir, 3, 0);
        }
        else
        {
            if(this->Data!=Ghost_Data)
                this->Data=Ghost_Data;
        }
    }
    
    // Resize, if necessary
    if(this->TileWidth!=Ghost_TileWidth)
    {
        this->TileWidth=Ghost_TileWidth;
        ghost->TileWidth=Ghost_TileWidth;
        ghost->HitWidth=16*Ghost_TileWidth;
        ghost->HitXOffset=0;
    }
    
    if(this->TileHeight!=Ghost_TileHeight)
    {
        this->TileHeight=Ghost_TileHeight;
        ghost->TileHeight=Ghost_TileHeight;
        ghost->HitHeight=16*Ghost_TileHeight;
        ghost->HitYOffset=0;
    }
    
    // Draw over if high enough
    if(Ghost_FlagIsSet(GHF_SET_OVERLAY))
    {
        if(Ghost_Z>=GH_DRAW_OVER_THRESHOLD && !this->Flags[FFCF_OVERLAY])
            this->Flags[FFCF_OVERLAY]=true;
        else if(Ghost_Z<GH_DRAW_OVER_THRESHOLD && this->Flags[FFCF_OVERLAY])
            this->Flags[FFCF_OVERLAY]=false;
    }
    
    ghost->HP=Ghost_HP;
    
    // Set CSet
    // ghost->CSet can't be forced; built-in flashing can't be prevented
    ghost->CSet=Ghost_CSet;
    if((__Ghost_InternalFlags&__GHFI_CSET_FORCED)!=0)
        this->CSet=Ghost_CSet;
    else if(__Ghost_FlashCounter<=0)
        this->CSet=Ghost_CSet;
    
    // Draw a shadow for fake Z movement
    if((Ghost_FlagIsSet(GHF_FAKE_Z) || GH_FAKE_Z>0) && Ghost_Z>0)
    {
        bool drawShadow=true;

        // Flickering?
        if(GH_SHADOW_FLICKER!=0)
        {
            if((__Ghost_InternalFlags&__GHFI_SHADOW_FLICKER)==0)
            {
                __Ghost_InternalFlags|=__GHFI_SHADOW_FLICKER;
                drawShadow=false;
            }
            else
                __Ghost_InternalFlags&=~__GHFI_SHADOW_FLICKER;
        }
        
        if(drawShadow)
        {
            int x=Ghost_X+8*(Ghost_TileWidth-1);
            int y=Ghost_Y+16*(Ghost_TileHeight-1);

            if(GH_SHADOW_TRANSLUCENT>0)
                Screen->DrawTile(1, x, y, GH_SHADOW_TILE, 1, 1, GH_SHADOW_CSET, -1, -1, 0, 0, 0, 0, true, 64);
            else
                Screen->DrawTile(1, x, y, GH_SHADOW_TILE, 1, 1, GH_SHADOW_CSET, -1, -1, 0, 0, 0, 0, true, 128);
        }
    }
}

// After waiting: Check whether the enemy was hit, stunned, or killed
bool __Ghost_WaitframePart2(ffc this, npc ghost, bool clearOnDeath, bool quitOnDeath)
{
    // Was the enemy removed somehow?
    if(!ghost->isValid())
    {
        if(clearOnDeath)
        {
            Ghost_ClearAttachedFFCs();
            this->Data=0;
        }
        if(quitOnDeath)
            Quit();
        return false;
    }

    // Is it dead?
    bool dead=false;

    if(ghost->HP<=0)
        dead=true;

    if(!dead)
    {
        // Hit?
        Ghost_CheckHit(this, ghost);

        // Stunned or frozen by a clock?
        dead=!Ghost_CheckFreeze(this, ghost);
    }

    Ghost_HP=ghost->HP;

    // Dead yet?
    if(dead)
    {
        if(clearOnDeath)
        {
            ghost->TileWidth=1;
            ghost->TileHeight=1;
            ghost->X=Ghost_X+8*(Ghost_TileWidth-1);
            ghost->Y=Ghost_Y+8*(Ghost_TileHeight-1);
            ghost->Z=Ghost_Z;
            this->Data=0;
        }

        if(quitOnDeath)
            Quit();

        return false;
    }

    return true;
}

// Does the actual initialization for the init functions
void __Ghost_InitInternal(ffc this, npc ghost, bool useEnemyPos, int combo, int cset)
{
    if(combo==__GH_INVISIBLE_ALT || combo==__GH_INVISIBLE_EXTEND)
        combo=GH_INVISIBLE_COMBO;
    
    if(useEnemyPos)
    {
        Ghost_X=ghost->X;
        Ghost_Y=ghost->Y;
        Ghost_Z=ghost->Z;
        Ghost_Jump=ghost->Jump;
    }
    else
    {
        Ghost_X=this->X;
        Ghost_Y=this->Y;
        Ghost_Z=0;
        Ghost_Jump=0;
        
        ghost->Z=0;
        ghost->Jump=0;
    }
    
    Ghost_SetPosition(this, ghost);
    Ghost_Dir=ghost->Dir;
    
    Ghost_Vx=0;
    Ghost_Vy=0;
    Ghost_Ax=0;
    Ghost_Ay=0;
    
    __Ghost_PrevX=Ghost_X;
    __Ghost_PrevY=Ghost_Y;
    

    this->Data=combo;
    Ghost_Data=combo;
    this->CSet=cset;
    Ghost_CSet=cset;
    
    Ghost_TileWidth=this->TileWidth;
    Ghost_TileHeight=this->TileHeight;
    __Ghost_XOffsets=0;
    __Ghost_YOffsets=0;
    
    if(combo!=GH_INVISIBLE_COMBO)
    {
        ghost->OriginalTile=GH_BLANK_TILE;
        ghost->Extend=3;
        ghost->TileWidth=Ghost_TileWidth;
        ghost->TileHeight=Ghost_TileHeight;
        ghost->HitWidth=16*Ghost_TileWidth;
        ghost->HitHeight=16*Ghost_TileHeight;
    }
    
    __Ghost_Flags=0;
    __Ghost_Flags2=0;
    __Ghost_FlashCounter=0;
    __Ghost_KnockbackCounter=0;
    
    Ghost_HP=ghost->HP;
    ghost->Misc[__GHI_IN_USE]=1;
    
    // Remember that this is a ghost script so it can be cleared at the appropriate times
    __Ghost_Scripts[this->Script>>4]|=1<<(this->Script&1111b);
}

// Used internally by walk functions to keep the enemy lined up with the grid correctly
void __Ghost_FixCoords()
{
    float newX=(Ghost_X&0xF0);
    if((Ghost_X&8)!=0)
        newX+=16;
    Ghost_X=newX;
    
    if((Screen->Flags[SF_ROOMTYPE]&100b)!=0) // If sideview
    {
        float newY=(Ghost_Y&0xF8);
        if((Ghost_Y&4)!=0)
            newY+=8;
        Ghost_Y=newY;
    }
    else
    {
        float newY=(Ghost_Y&0xF0);
        if((Ghost_Y&8)!=0)
            newY+=16;
        Ghost_Y=newY;
    }
}

// Determines the direction to Link
int __Ghost_LinedUp(int range, bool eightWay)
{
    // Up or down
    if(Abs(Link->X-Ghost_X)<=range)
    {
        if(Link->Y<Ghost_Y)
            return DIR_UP;
        else
            return DIR_DOWN;
    }
    // Left or right
    else if(Abs(Link->Y-Ghost_Y)<=range)
    {
        if(Link->X<Ghost_X)
            return DIR_LEFT;
        else
            return DIR_RIGHT;
    }

    // Diagonal
    if (eightWay)
    {
        if (Abs(Link->X-Ghost_X)-Abs(Link->Y-Ghost_Y)<=range)
        {
            if (Link->Y<Ghost_Y)
            {
                if (Link->X<Ghost_X)
                    return DIR_LEFTUP;
                else
                    return DIR_RIGHTUP;
            }
            else
            {
                if (Link->X<Ghost_X)
                    return DIR_LEFTDOWN;
                else
                    return DIR_RIGHTDOWN;
            }
        }
    }

    // Not in range
    return -1;
}

// Used by walk functions to pick a new direction
void __Ghost_NewDir4(int rate, int homing, int hunger)
{
    int newDir=-1;
    // Go for bait?
    if(Rand(4)<hunger)
    {
        // See if any is on the screen
        lweapon bait=LoadLWeaponOf(LW_BAIT);
        
        if(bait->isValid())
        {
            // Found bait; try to move toward it
            if(Abs(Ghost_Y-bait->Y)>14)
            {
                if(bait->Y<Ghost_Y)

                    newDir=DIR_UP;
                else
                    newDir=DIR_DOWN;
                
                if(Ghost_CanMove(newDir, 1, 0))
                {
                    Ghost_Dir=newDir;
                    return;
                }
            }
            
            if(bait->X<Ghost_X)
                newDir=DIR_LEFT;
            else
                newDir=DIR_RIGHT;
            
            if(Ghost_CanMove(newDir, 1, 0))
            {
                Ghost_Dir=newDir;
                return;
            }
        }
    } // End hunger check
    
    // Homing?
    if(Rand(256)<homing)
    {
        newDir=__Ghost_LinedUp(8, false);
        if(newDir>=0 && Ghost_CanMove(newDir, 1, 0))
        {
            Ghost_Dir=newDir;
            return;
        }
    }
    
    // Check solidity of surrounding combos
    bool combos[4];
    int numDirs;
    int counter;
    
    // Don't bother checking upward in sideview if GHF_NO_FALL isn't set
    if(!IsSideview() || Ghost_FlagIsSet(GHF_NO_FALL))
    {
        if(__FullTileWalkable(Ghost_X, Ghost_Y-16))
        {
            combos[DIR_UP]=true;
            numDirs++;
        }
    }
    
    if(__FullTileWalkable(Ghost_X, Ghost_Y+16))
    {
        combos[DIR_DOWN]=true;
        numDirs++;
    }
    
    if(__FullTileWalkable(Ghost_X-16, Ghost_Y))
    {
        combos[DIR_LEFT]=true;
        numDirs++;
    }
    
    if(__FullTileWalkable(Ghost_X+16, Ghost_Y))
    {
        combos[DIR_RIGHT]=true;
        numDirs++;
    }
    
    // Trapped?
    if(numDirs==0)
    {
        Ghost_Dir=-1;
        return;
    }
    
    // Pick a direction at random from the ones available
    counter=Rand(numDirs);
    for(int dir=0; dir<4; dir++)
    {
        if(!combos[dir])
            continue;
        
        if(counter==0)
        {
            Ghost_Dir=dir;
            return;
        }
        else
            counter--;
    }
}

// Used by walk functions to pick a new direction
void __Ghost_NewDir8(int rate, int homing, int hunger)
{
    int newDir=-1;

    // If the enemy can keep moving, it can turn voluntarily
    if(Ghost_CanMove(Ghost_Dir, 1, 0))
    {
        if(Rand(4)<hunger)
        {
            // Any bait around?
            lweapon bait=LoadLWeaponOf(LW_BAIT);

            if(bait->isValid())
            {
                // Go toward it
                if(bait->X<Ghost_X)
                    newDir=DIR_LEFT;
                else if(bait->X>Ghost_X)
                    newDir=DIR_RIGHT;
                else
                    newDir=0;

                if(Abs(Ghost_Y-bait->Y)>14)
                {
                    if(newDir>0)
                    {
                        if(bait->Y<Ghost_Y)
                            newDir+=2;
                        else
                            newDir+=4;
                    }
                    else
                    {
                        if(bait->Y<Ghost_Y)
                            newDir=DIR_UP;
                        else
                            newDir=DIR_DOWN;
                    }
                }

                if(Ghost_CanMove(newDir, 1, 0))
                {
                    Ghost_Dir=newDir;
                    Ghost_X<<=0;
                    Ghost_Y<<=0;
                    return;
                }
            }
        } // End hunger check

        // Aim at Link?
        if(Rand(256)<homing)
        {
            newDir=__Ghost_LinedUp(8, true);
            if(newDir>=0 && Ghost_CanMove(newDir, 1, 0))
            {
                Ghost_Dir=newDir;
                Ghost_X<<=0;
                Ghost_Y<<=0;
                return;
            }
        }

        // Didn't go for bait or Link; keep going straight?
        if(Rand(16)>=rate)
            return;
    }

    // Either randomly chose to turn or has no choice

    // See which ways the enemy can go
    bool dirs[8];
    int numDirs;
    int counter;

    for(int i=0; i<8; i++)
    {
        if(Ghost_CanMove(i, 1, 0))
        {
            numDirs++;
            dirs[i]=true;
        }
    }

    // Trapped?
    if(numDirs==0)
    {
        Ghost_Dir=-1;
        Ghost_X<<=0;
        Ghost_Y<<=0;
        return;
    }

    // Pick a random direction
    counter=Rand(numDirs);
    for(int dir=0; dir<8; dir++)
    {
        if(!dirs[dir])
            continue;

        if(counter==0)
        {
            Ghost_Dir=dir;
            Ghost_X<<=0;
            Ghost_Y<<=0;
            return;
        }
        else
            counter--;
    }
}

// Make a copy of the given eweapon, which should be a dummy
void __CopyEWeapon(eweapon prototype, int centerX, int centerY, float angle)
{
    eweapon wpn=Screen->CreateEWeapon(prototype->ID);
    if(prototype->Misc[__EWI_DUMMY_SPRITE]>0)
        wpn->UseSprite(prototype->Misc[__EWI_DUMMY_SPRITE]);

    if(prototype->Extend==3)
    {
        wpn->Extend=3;
        wpn->TileWidth=prototype->TileWidth;
        wpn->TileHeight=prototype->TileHeight;
        wpn->HitWidth=16*prototype->TileWidth;
        wpn->HitHeight=16*prototype->TileHeight;
        wpn->X=centerX-8*wpn->TileWidth;
        wpn->Y=centerY-8*wpn->TileWidth;
    }
    else
    {
        wpn->X=centerX-8;
        wpn->Y=centerY-8;
    }

    wpn->Step=prototype->Misc[__EWI_DUMMY_STEP];
    wpn->Damage=prototype->Damage;
    wpn->Angular=true;
    wpn->Angle=angle;
    SetEWeaponDir(wpn);

    wpn->Misc[__EWI_XPOS]=wpn->X;
    wpn->Misc[__EWI_YPOS]=wpn->Y;
    wpn->Misc[__EWI_MOVEMENT]=prototype->Misc[__EWI_MOVEMENT];

    // Special case for thrown weapons with automatic velocity
    if(prototype->Misc[__EWI_MOVEMENT]==EWM_THROW && prototype->Misc[__EWI_MOVEMENT_ARG]==-1)
    {
        float time=Distance(centerX, centerY, Link->X+8, Link->Y+8)/(wpn->Step/100);
        wpn->Misc[__EWI_MOVEMENT_ARG]=GH_GRAVITY*time/2;
    }
    else
        wpn->Misc[__EWI_MOVEMENT_ARG]=prototype->Misc[__EWI_MOVEMENT_ARG];

    wpn->Misc[__EWI_LIFESPAN]=prototype->Misc[__EWI_LIFESPAN];
    wpn->Misc[__EWI_LIFESPAN_ARG]=prototype->Misc[__EWI_LIFESPAN_ARG];
    wpn->Misc[__EWI_ON_DEATH]=prototype->Misc[__EWI_ON_DEATH];
    wpn->Misc[__EWI_ON_DEATH_ARG]=prototype->Misc[__EWI_ON_DEATH_ARG];
    wpn->Misc[__EWI_FLAGS]=(prototype->Misc[__EWI_FLAGS]&(~__EWFI_DUMMY));

    if((wpn->Misc[__EWI_FLAGS]&EWF_NO_COLLISION)!=0)
        wpn->CollDetection=false;

    if((wpn->Misc[__EWI_FLAGS]&EWF_ROTATE)!=0)
        SetEWeaponRotation(wpn);
}

// Returns true if the only if the full tile at the given location is walkable
bool __FullTileWalkable(int x, int y)
{
    // Offscreen?
    if(x<0 || y<0 || x>=256 || y>=176)
        return Ghost_FlagIsSet(GHF_MOVE_OFFSCREEN);
    
    // Get the exact coordinate of the top-left pixel
    x-=x%16;
    y-=y%16;
    
    if(Screen->isSolid(x, y) ||
       Screen->isSolid(x+8, y) ||
       Screen->isSolid(x, y+8) ||
       Screen->isSolid(x+8, y+8))
        return false;
    
    return true;
}

void __Ghost_UpdateFlashing(ffc this, npc ghost)
{
    if(__Ghost_FlashCounter>=1)
    {
        // Flash
        if(GH_ENEMIES_FLICKER==0)
        {
            if(__Ghost_FlashCounter>1)
            {
                // Cycle through CSets 6-7-8-9
                if((__Ghost_InternalFlags&__GHFI_CSET_FORCED)==0)
                    this->CSet=9-(__Ghost_FlashCounter&3);
                __Ghost_FlashCounter--;
            }
            // Done flashing
            else if(__Ghost_FlashCounter==1)
            {
                if((__Ghost_InternalFlags&__GHFI_CSET_FORCED)==0)
                    this->CSet=Ghost_CSet;
                __Ghost_FlashCounter=0;
            }
        }
        
        // Flicker
        else
        {
            if(__Ghost_FlashCounter>1)
            {
                // Just set a flag; the actual flickering is handled in Ghost_WaitframeLight
                if((__Ghost_FlashCounter&1)==1)
                    __Ghost_InternalFlags|=__GHFI_FLICKER;
                else
                    __Ghost_InternalFlags&=~__GHFI_FLICKER;
                __Ghost_FlashCounter--;
            }
            // Done flickering
            else if(__Ghost_FlashCounter==1)
            {
                __Ghost_FlashCounter=0;
                __Ghost_InternalFlags&=~__GHFI_FLICKER;
            }
        }
    }
}


// =================================
// |||| DEPRECATED - DO NOT USE ||||
// =================================

void Ghost_Init(ffc this, npc ghost, int flags)
{
    Ghost_Init(this, ghost);
    Ghost_SetFlags(flags);
}

npc Ghost_InitCreate(ffc this, int enemyID, int flags)
{
    npc ghost=Ghost_InitCreate(this, enemyID);
    Ghost_SetFlags(flags);
    return ghost;
}

npc Ghost_InitWait(ffc this, int enemyIndex, bool useEnemyPos, int flags)
{
    npc ghost=Ghost_InitWait(this, enemyIndex, useEnemyPos);
    Ghost_SetFlags(flags);
    return ghost;
}

npc Ghost_InitWait2(ffc this, int enemyID, bool useEnemyPos, int flags)
{
    npc ghost=Ghost_InitWait2(this, enemyID, useEnemyPos);
    Ghost_SetFlags(flags);
    return ghost;
}

npc Ghost_InitSpawn(ffc this, int enemyID, int flags)
{
    npc ghost=Ghost_InitSpawn(this, enemyID);
    Ghost_SetFlags(flags);
    return ghost;
}

npc Ghost_InitAutoGhost(ffc this, int enemyID, int flags)
{
    npc ghost=Ghost_InitAutoGhost(this, enemyID);
    Ghost_SetFlags(flags);
    return ghost;
}

void Ghost_SetFlags(int flags)
{
    __Ghost_Flags=flags;
}

void Ghost_WaitframeLight()
{
    // Remember all the global variables
    float tempGhostX=Ghost_X;
    float tempGhostY=Ghost_Y;
    float tempGhostZ=Ghost_Z;
    float tempGhostJump=Ghost_Jump;
    float tempGhostVx=Ghost_Vx;
    float tempGhostVy=Ghost_Vy;
    float tempGhostAx=Ghost_Ax;
    float tempGhostAy=Ghost_Ay;
    float tempGhostPrevX=__Ghost_PrevX;
    float tempGhostPrevY=__Ghost_PrevY;
    int tempGhostCSet=Ghost_CSet;
    int tempGhostDir=Ghost_Dir;
    int tempGhostData=Ghost_Data;
    int tempGhostTileWidth=Ghost_TileWidth;
    int tempGhostTileHeight=Ghost_TileHeight;
    int tempGhostFlags=__Ghost_Flags;
    int tempGhostFlags2=__Ghost_Flags2;
    int tempGhostInternalFlags=__Ghost_InternalFlags;
    int tempGhostFlashCounter=__Ghost_FlashCounter;
    int tempGhostKnockbackCounter=__Ghost_KnockbackCounter;
    int tempGhostHP=Ghost_HP;
    int tempGhostXOffsets=__Ghost_XOffsets;
    int tempGhostYOffsets=__Ghost_YOffsets;
    int tempGhostAttachedFFCs=__Ghost_AttachedFFCs;
    
    Waitframe();
    
    // Restore the global variables
    Ghost_X=tempGhostX;
    Ghost_Y=tempGhostY;
    Ghost_Z=tempGhostZ;
    Ghost_Jump=tempGhostJump;
    Ghost_Vx=tempGhostVx;
    Ghost_Vy=tempGhostVy;
    Ghost_Ax=tempGhostAx;
    Ghost_Ay=tempGhostAy;
    __Ghost_PrevX=tempGhostPrevX;
    __Ghost_PrevY=tempGhostPrevY;
    Ghost_CSet=tempGhostCSet;
    Ghost_Dir=tempGhostDir;
    Ghost_Data=tempGhostData;
    Ghost_TileWidth=tempGhostTileWidth;
    Ghost_TileHeight=tempGhostTileHeight;
    __Ghost_Flags=tempGhostFlags;
    __Ghost_Flags2=tempGhostFlags2;
    __Ghost_InternalFlags=tempGhostInternalFlags;
    __Ghost_FlashCounter=tempGhostFlashCounter;
    __Ghost_KnockbackCounter=tempGhostKnockbackCounter;
    Ghost_HP=tempGhostHP;
    __Ghost_XOffsets=tempGhostXOffsets;
    __Ghost_YOffsets=tempGhostYOffsets;
    __Ghost_AttachedFFCs=tempGhostAttachedFFCs;
}

void Ghost_WaitframesLight(int numFrames)
{
    for(; numFrames>0; numFrames--)
        Ghost_WaitframeLight();
}

