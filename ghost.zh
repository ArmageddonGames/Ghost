// See ghost.txt for documentation.

// World settings
const int GH_DRAW_OVER_THRESHOLD = 32;
const float GH_GRAVITY = 0.16;
const float GH_TERMINAL_VELOCITY = 3.2;
const int GH_SPAWN_SPRITE = 22;

// Shadow settings
const int GH_SHADOW_TILE = 73;
const int GH_SHADOW_CSET = 0;
const int GH_SHADOW_TRANSLUCENT = 1; // Set to 0 or 1

// Top-left corner of a 4x4 block of blank tiles
const int GH_BLANK_TILE = 65456;

// npc->Misc[] indices
// Set these constants so they don't conflict with other scripts.
// Legal values are 0-15. They must all be different.
const int GHI_KNOCKBACK_COUNTER = 12;
const int GHI_FLASH_COUNTER     = 13;
const int GHI_FLAGS             = 14;
const int GHI_PREV_HP           = 15;

// eweapon->Misc[] indices
// Like the above, these must be unique numbers between 0 and 15.
const int EWI_XPOS         = 5;
const int EWI_YPOS         = 6;
const int EWI_WORK         = 7;
const int EWI_WORK_2       = 8; // Only used by a few movement types
const int EWI_MOVEMENT     = 9;
const int EWI_MOVEMENT_ARG = 10; 
const int EWI_LIFESPAN     = 11;
const int EWI_LIFESPAN_ARG = 12;
const int EWI_ON_DEATH     = 13;
const int EWI_ON_DEATH_ARG = 14;
const int EWI_FLAGS        = 15; // Every index but this one can be used by non-ghost.zh-spawned eweapons

// Customizable constants end here --------------------------------------------



// Enemy flags
const int GHF_KNOCKBACK          = 00000000001b;
const int GHF_STUN               = 00000000010b;
const int GHF_NO_FALL            = 00000000100b;
const int GHF_SET_DIRECTION      = 00000001000b;
const int GHF_SET_OVERLAY        = 00000010000b;
const int GHF_4WAY               = 00000100000b;
const int GHF_IGNORE_SOLIDITY    = 00001000000b;
const int GHF_IGNORE_WATER       = 00010000000b;
const int GHF_IGNORE_PITS        = 00100000000b;
const int GHF_IGNORE_ALL_TERRAIN = 00111000000b;
const int GHF_NORMAL             = 00000001011b;

const int GHF_GOT_HIT            = 01000000000b; // Internal use
const int GHF_IN_USE             = 10000000000b; // Internal use
const int GHF_INTERNAL           = 11000000000b; // Internal use

// Arguments to SetEWeaponMovement()
const int EWM_SINE_WAVE      = 1;
const int EWM_SINE_WAVE_FAST = 2;
const int EWM_HOMING         = 3;
const int EWM_HOMING_REAIM   = 4;
const int EWM_RANDOM         = 5;
const int EWM_RANDOM_REAIM   = 6;
const int EWM_VEER_UP        = 7;
const int EWM_VEER_DOWN      = 8;
const int EWM_VEER_LEFT      = 9;
const int EWM_VEER_RIGHT     = 10;
const int EWM_THROW          = 11;
const int EWM_FALL           = 12;

// Arguments to SetEWeaponLifespan()
const int EWL_TIMER        = 1;
const int EWL_NEAR_LINK    = 2;
const int EWL_SLOW_TO_HALT = 3;

// Arguments to SetEWeaponDeathEffect()
const int EWD_VANISH             = 1;
const int EWD_AIM_AT_LINK        = 2;
const int EWD_EXPLODE            = 3;
const int EWD_SBOMB_EXPLODE      = 4;
const int EWD_4_FIREBALLS_HV     = 5;
const int EWD_4_FIREBALLS_DIAG   = 6;
const int EWD_4_FIREBALLS_RANDOM = 7;
const int EWD_8_FIREBALLS        = 8;
const int EWD_4_FIRES_HV         = 9;
const int EWD_4_FIRES_DIAG       = 10;
const int EWD_4_FIRES_RANDOM     = 11;
const int EWD_8_FIRES            = 12;
const int EWD_SPAWN_NPC          = 13;

// EWeapon flags
const int EWF_UNBLOCKABLE  = 000001b;
const int EWF_ROTATE       = 000010b;
const int EWF_SHADOW       = 000100b;
const int EWF_FLICKER      = 001000b;

const int EWF_DEAD         = 010000b; // Internal use
const int EWF_IS_GHZH_EWPN = 100000b; // Internal use
const int EWF_INTERNAL     = 110000b; // Internal use



// ========================
// |||| INITIALIZATION ||||
// ========================

void GhostInit(ffc this, npc ghost)
{
    if(ghost->ASpeed==256 && GH_BLANK_TILE>0)
        ghost->OriginalTile=GH_BLANK_TILE;
    ghost->Extend=3;
    ghost->TileWidth=this->TileWidth;
    ghost->TileHeight=this->TileHeight;
    ghost->HitWidth=16*this->TileWidth;
    ghost->HitHeight=16*this->TileHeight;
    ghost->X=this->X;
    ghost->Y=this->Y;
    ghost->CSet=this->CSet;
    ghost->Misc[GHI_FLASH_COUNTER]=0;
    ghost->Misc[GHI_PREV_HP]=ghost->HP;
    ghost->Misc[GHI_FLAGS]|=GHF_IN_USE;
}

npc GhostInitCreate(ffc this, int enemyID)
{
    npc ghost=Screen->CreateNPC(enemyID);
    GhostInit(this, ghost);
    return ghost;
}

npc GhostInitWait(ffc this, int enemyIndex, bool useEnemyPos)
{
    int combo=this->Data;
    this->Data=0;
    npc ghost;
    
    for(int i=0; i<4; i++)
    {
        if(Screen->NumNPCs()>=enemyIndex)
        {
            ghost=Screen->LoadNPC(enemyIndex);
            ghost->Extend=3;
            ghost->TileWidth=this->TileWidth;
            ghost->TileHeight=this->TileHeight;
            if(ghost->ASpeed==256 && GH_BLANK_TILE>0)
                ghost->OriginalTile=GH_BLANK_TILE;
            ghost->Extend=3;
            ghost->TileWidth=this->TileWidth;
            ghost->TileHeight=this->TileHeight;
            ghost->HitWidth=16*this->TileWidth;
            ghost->HitHeight=16*this->TileHeight;
            ghost->CSet=this->CSet;
            ghost->Misc[GHI_FLASH_COUNTER]=0;
            ghost->Misc[GHI_PREV_HP]=ghost->HP;
            ghost->Misc[GHI_FLAGS]|=GHF_IN_USE;
            this->Data=combo;
            
            if(useEnemyPos)
            {
                this->X=ghost->X;
                this->Y=ghost->Y;
            }
            else
            {
                ghost->X=this->X;
                ghost->Y=this->Y;
            }
            
            return ghost;
        }
        Waitframe();
    }
    // Timed out
    Quit();
}

npc GhostInitWait2(ffc this, int enemyID, bool useEnemyPos)
{
    int combo=this->Data;
    this->Data=0;
    npc ghost;
    
    for(int i=0; i<4; i++)
    {
        // Cycle through enemies to find the right one
        for(int j=1; j<=Screen->NumNPCs(); j++)
        {
            ghost=Screen->LoadNPC(j);
            // Wrong ID?
            if(ghost->ID!=enemyID)
                continue;
            // Already in use?
            if((ghost->Misc[GHI_FLAGS]&GHF_IN_USE)!=0)
                continue;
            
            // Found it; initialize
            if(ghost->ASpeed==256 && GH_BLANK_TILE>0)
                ghost->OriginalTile=GH_BLANK_TILE;
            ghost->Extend=3;
            ghost->TileWidth=this->TileWidth;
            ghost->TileHeight=this->TileHeight;
            ghost->HitWidth=16*this->TileWidth;
            ghost->HitHeight=16*this->TileHeight;
            ghost->CSet=this->CSet;
            ghost->Misc[GHI_FLASH_COUNTER]=0;
            ghost->Misc[GHI_PREV_HP]=ghost->HP;
            ghost->Misc[GHI_FLAGS]|=GHF_IN_USE;
            this->Data=combo;
            
            if(useEnemyPos)
            {
                this->X=ghost->X;
                this->Y=ghost->Y;
            }
            else
            {
                ghost->X=this->X;
                ghost->Y=this->Y;
            }
            
            return ghost;
        }
        Waitframe();
    }
    // Timed out
    Quit();
}

npc GhostInitSpawn(ffc this, int enemyID)
{
    npc ghost=SpawnNPC(enemyID);
    if(ghost->ASpeed==256 && GH_BLANK_TILE>0)
        ghost->OriginalTile=GH_BLANK_TILE;
    ghost->Extend=3;
    ghost->TileWidth=this->TileWidth;
    ghost->TileHeight=this->TileHeight;
    ghost->HitWidth=16*this->TileWidth;
    ghost->HitHeight=16*this->TileHeight;
    ghost->CSet=this->CSet;
    ghost->Misc[GHI_FLASH_COUNTER]=0;
    ghost->Misc[GHI_PREV_HP]=ghost->HP;
    ghost->Misc[GHI_FLAGS]|=GHF_IN_USE;
    
    return ghost;
}

void GhostInit(ffc this, npc ghost, int flags)
{
    GhostInit(this, ghost);
    SetFlags(this, ghost, flags);
}

npc GhostInitCreate(ffc this, int enemyID, int flags)
{
    npc ghost=GhostInitCreate(this, enemyID);
    SetFlags(this, ghost, flags);
    return ghost;
}

npc GhostInitWait(ffc this, int enemyIndex, bool useEnemyPos, int flags)
{
    npc ghost=GhostInitWait(this, enemyIndex, useEnemyPos);
    SetFlags(this, ghost, flags);
    return ghost;
}

npc GhostInitWait2(ffc this, int enemyID, bool useEnemyPos, int flags)
{
    npc ghost=GhostInitWait2(this, enemyID, useEnemyPos);
    SetFlags(this, ghost, flags);
    return ghost;
}

npc GhostInitSpawn(ffc this, int enemyID, int flags)
{
    npc ghost=GhostInitSpawn(this, enemyID);
    SetFlags(this, ghost, flags);
    return ghost;
}

void SetFlags(ffc this, npc ghost, int flags)
{
    ghost->Misc[GHI_FLAGS]=flags|(ghost->Misc[GHI_FLAGS]&GHF_INTERNAL);
    if((flags&GHF_4WAY)!=0)
        this->Data=this->Data+ghost->Dir;
}

void DrawSpawnAnimation(ffc this, npc ghost)
{
    int i;
    int j;
    lweapon graphic;
    
    int combo=this->Data;
    this->Data=0;
    ghost->CollDetection=false;
    ghost->DrawXOffset=32768;
    
    for(i=0; i<this->TileWidth; i++)
    {
        for(j=0; j<this->TileHeight; j++)
        {
            graphic=Screen->CreateLWeapon(LW_SCRIPT10);
            graphic->CollDetection=false;
            graphic->UseSprite(GH_SPAWN_SPRITE);
            graphic->X=this->X+16*i;
            graphic->Y=this->Y+16*j;
            
            if(graphic->NumFrames==0)
                graphic->NumFrames=3;
            if(graphic->ASpeed==0)
                graphic->ASpeed=4;
            
            graphic->DeadState=graphic->NumFrames*graphic->ASpeed;
        }
    }
    if(graphic->isValid()) // Not sure this line's necessary, but it can't hurt
        Waitframes(graphic->NumFrames*graphic->ASpeed);
    
    this->Data=combo;
    ghost->CollDetection=true;
    ghost->DrawXOffset=0;
}

// ================
// |||| UPDATE ||||
// ================

bool GhostWaitframeM(ffc this, npc ghost, float x, float y, float z, bool clearOnDeath, bool quitOnDeath)
{
    // Set direction
    if((ghost->Misc[GHI_FLAGS]&GHF_SET_DIRECTION)!=0 && (this->X!=x || (this->Y+ghost->Z)!=y))
    {
        // Figure out the base combo, in case GHF_4WAY is set
        int baseCombo=this->Data-ghost->Dir;
        
        if(Abs(this->X-x)>Abs((this->Y+ghost->Z)-y))
        {
            if(this->X>x)
                ghost->Dir=DIR_LEFT;
            else
                ghost->Dir=DIR_RIGHT;
        }
        else
        {
            if(this->Y+ghost->Y>y)
                ghost->Dir=DIR_UP;
            else
                ghost->Dir=DIR_DOWN;
        }
        
        // Change combo to match
        if((ghost->Misc[GHI_FLAGS]&GHF_4WAY)!=0)
            this->Data=baseCombo+ghost->Dir;
    }
    
    // Draw over if high enough

    if((ghost->Misc[GHI_FLAGS]&GHF_SET_OVERLAY)!=0)
    {
        if(z>=GH_DRAW_OVER_THRESHOLD && !this->Flags[FFCF_OVERLAY])
            this->Flags[FFCF_OVERLAY]=true;
        else if(z<GH_DRAW_OVER_THRESHOLD && this->Flags[FFCF_OVERLAY])
            this->Flags[FFCF_OVERLAY]=false;
    }
    
    if((ghost->Misc[GHI_FLAGS]&GHF_NO_FALL)!=0)
        ghost->Jump=0;
    
    // Set position
    ghost->X=x;
    ghost->Y=y;
    ghost->Z=z;
    this->X=Max(-64, Min(256, x)); // The FFC shouldn't go too far offscreen, or it will disappear
    this->Y=Max(-64, Min(176, y-z));
    
    Waitframe();
    
    // Dead?
    if(!ghost->isValid())
    {
        if(clearOnDeath)
            this->Data=0;
        if(quitOnDeath)
            Quit();
        return false;
    }
    
    if(ghost->HP<=0)
    {
        if(clearOnDeath)
        {
            ghost->TileWidth=1;
            ghost->TileHeight=1;
            ghost->X=this->X+8*(this->TileWidth-1);
            ghost->Y=this->Y+8*(this->TileHeight-1);
            this->Data=0;
        }
        
        if(quitOnDeath)
            Quit();
        return false;
    }
    
    // Hit?
    CheckHit(this, ghost);
    if((ghost->Misc[GHI_FLAGS]&GHF_STUN)!=0)
        CheckStun(this, ghost);
    
    return true;
}

bool GhostWaitframeN(ffc this, npc ghost, bool clearOnDeath, bool quitOnDeath)
{
    GhostWaitframeM(this, ghost, ghost->X, ghost->Y, ghost->Z, clearOnDeath, quitOnDeath);
}

bool GhostWaitframeF(ffc this, npc ghost, bool clearOnDeath, bool quitOnDeath)
{
    GhostWaitframeM(this, ghost, this->X, this->Y, 0, clearOnDeath, quitOnDeath);
}

bool GhostWaitframesM(ffc this, npc ghost, float x, float y, float z, bool clearOnDeath, bool quitOnDeath, int numFrames)
{
    while(numFrames-->0)
        GhostWaitframeM(this, ghost, x, y, z, clearOnDeath, quitOnDeath);
}

bool GhostWaitframesN(ffc this, npc ghost, bool clearOnDeath, bool quitOnDeath, int numFrames)
{
    while(numFrames-->0)
        GhostWaitframeM(this, ghost, ghost->X, ghost->Y, ghost->Z, clearOnDeath, quitOnDeath);
}

bool GhostWaitframesF(ffc this, npc ghost, bool clearOnDeath, bool quitOnDeath, int numFrames)
{
    while(numFrames-->0)
        GhostWaitframeM(this, ghost, this->X, this->Y, 0, clearOnDeath, quitOnDeath);
}

void CheckHit(ffc this, npc ghost)
{
    // Just got hit - set flash and knockback counters
    if(ghost->HP<ghost->Misc[GHI_PREV_HP])
    {
        ghost->Misc[GHI_FLAGS]|=GHF_GOT_HIT;
        ghost->Misc[GHI_PREV_HP]=ghost->HP;
        ghost->Misc[GHI_FLASH_COUNTER]=32;
        
        // Set knockback
        if((ghost->Misc[GHI_FLAGS]&GHF_KNOCKBACK)!=0)
        {
            int xDiff=Link->X-ghost->X;
            int yDiff=Link->Y-ghost->Y;
            
            // The direction can't be checked the proper way, so guess based on Link's position
            
            // If close, use Link's direction
            if(Sqrt(xDiff*xDiff+yDiff*yDiff)<32)
            {
                if((Link->Dir&10b)==(ghost->Dir&10b)) // Both horizontal or vertical
                    ghost->Misc[GHI_KNOCKBACK_COUNTER]=Link->Dir<<5|16;
            }
            // If far, use relative positions
            else
            {
                if(Abs(xDiff)<Abs(yDiff)) // Up or down
                {
                    if(ghost->Dir==DIR_UP || ghost->Dir==DIR_DOWN)
                    {
                        if(yDiff>0)
                            ghost->Misc[GHI_KNOCKBACK_COUNTER]=(DIR_UP<<5)|16;
                        else
                            ghost->Misc[GHI_KNOCKBACK_COUNTER]=(DIR_DOWN<<5)|16;
                    }
                }
                else // Left or right
                {
                    if(ghost->Dir==DIR_LEFT || ghost->Dir==DIR_RIGHT)
                    {
                        if(xDiff>0)
                            ghost->Misc[GHI_KNOCKBACK_COUNTER]=(DIR_LEFT<<5)|16;
                        else
                            ghost->Misc[GHI_KNOCKBACK_COUNTER]=(DIR_RIGHT<<5)|16;
                    }
                }
            }
        }
    }
    // Not hit; unset flag
    else if((ghost->Misc[GHI_FLAGS]&GHF_GOT_HIT)!=0)
        ghost->Misc[GHI_FLAGS]&=(~GHF_GOT_HIT);
    
    // Flash
    if(ghost->Misc[GHI_FLASH_COUNTER]>1)
    {
        this->CSet=9-(ghost->Misc[GHI_FLASH_COUNTER]&3);
        ghost->Misc[GHI_FLASH_COUNTER]--;
    }
    // Done flashing
    else if(ghost->Misc[GHI_FLASH_COUNTER]==1)
    {
        ghost->Misc[GHI_FLASH_COUNTER]=0;
        this->CSet=ghost->CSet;
    }
    
    // Handle knockback
    if(ghost->Misc[GHI_KNOCKBACK_COUNTER]!=0)
    {
        int dir=ghost->Misc[GHI_KNOCKBACK_COUNTER]>>5;
        int counter=ghost->Misc[GHI_KNOCKBACK_COUNTER]&31;
        
        // Get knocked back
        if(CanMove(this, ghost, dir, 4, 0))
        {
            counter--;
            if(counter>0)
                ghost->Misc[GHI_KNOCKBACK_COUNTER]=(dir<<5)|counter;
            else
                ghost->Misc[GHI_KNOCKBACK_COUNTER]=0;
            
            if(dir==DIR_UP)
            {
                this->Y-=4;
                ghost->Y-=4;
            }
            else if(dir==DIR_DOWN)
            {
                this->Y+=4;
                ghost->Y+=4;
            }
            else if(dir==DIR_LEFT)
            {
                this->X-=4;
                ghost->X-=4;
            }
            else // Right
            {
                this->X+=4;
                ghost->X+=4;
            }
        }
        
        // Can't go any farther; end knockback
        else
        {
            ghost->Misc[GHI_KNOCKBACK_COUNTER]=0;
            
            if(dir==DIR_UP)
            {
                ghost->Y&=~7;
                this->Y=ghost->Y-ghost->Z;
            }
            else if(dir==DIR_DOWN)
            {
                if(ghost->Y%8!=0)
                {
                    ghost->Y=(ghost->Y&~7)+8;
                    this->Y=ghost->Y-ghost->Z;
                }
            }
            else if(dir==DIR_LEFT)
            {
                ghost->X&=~7;
                this->X=ghost->X;
            }
            else // Right
            {
                if(ghost->X%8!=0)
                {
                    ghost->X=(ghost->X&~7)+8;
                    this->X=ghost->X;
                }
            }
        }
    }
}

bool CheckStun(ffc this, npc ghost)
{
    if(ghost->Stun>0)
    {
        // Stop all movement
        float vx=this->Vx;
        float vy=this->Vy;
        float ax=this->Ax;
        float ay=this->Ay;
        
        this->Vx=0;
        this->Vy=0;
        this->Ax=0;
        this->Ay=0;
        
        // Do nothing except get hit until recovered
        while(ghost->Stun>0)
        {
            Waitframe();
            if(!ghost->isValid() || ghost->HP<=0)
                return false;
            CheckHit(this, ghost);
            
            // If the ghost shouldn't get knocked back, make sure it doesn't
            if((ghost->Misc[GHI_FLAGS]&GHF_KNOCKBACK)==0)
            {
                ghost->X=this->X;
                ghost->Y=this->Y+ghost->Z;
            }
        }
        
        // Restore movement
        this->Vx=vx;
        this->Vy=vy;
        this->Ax=ax;
        this->Ay=ay;
    }
    return true;
}


// ===============
// |||| OTHER ||||
// ===============

bool CanMove(ffc this, npc ghost, int dir, float step, int imprecision)
{
    int y=this->Y+ghost->Z;
    
    if(dir==DIR_UP)
    {
        // Screen edges
        if((Screen->Flags[SF_ROOMTYPE]&010b)!=0 && y-step<32)
            return false;
        else if(y-step<0)
            return false;
        
        int y2=y-step;
        int flags=ghost->Misc[GHI_FLAGS];
        
        // Check every 8 pixels for solid, pit, or water
        for(int i=imprecision; i<this->TileWidth*16-imprecision; i+=8)
        {
            if(!CanMovePixel(this->X+i, y2, flags))
                return false;
        }
        
        // One last pixel...
        if(!CanMovePixel(this->X+16*this->TileWidth-1-imprecision, y2, flags))
            return false;
        
        return true;
    }
    else if(dir==DIR_DOWN)
    {
        if((Screen->Flags[SF_ROOMTYPE]&010b)!=0 && y+16*this->TileHeight+step>=144)
            return false;
        else if(y+16*this->TileHeight+step>=176)
            return false;
        
        int y2=y+16*this->TileHeight+step;
        int flags=ghost->Misc[GHI_FLAGS];
        
        for(int i=imprecision; i<this->TileWidth*16-imprecision; i+=8)
        {
            if(!CanMovePixel(this->X+i, y2, flags))
                return false;
        }
        
        if(!CanMovePixel(this->X+16*this->TileWidth-1-imprecision, y2, flags))
            return false;
        
        return true;
    }
    else if(dir==DIR_LEFT)
    {
        if((Screen->Flags[SF_ROOMTYPE]&010b)!=0 && this->X-step<32)
            return false;
        else if(this->X-step<0)
            return false;
        
        int x2=this->X-step;
        int flags=ghost->Misc[GHI_FLAGS];
        
        for(int i=imprecision; i<this->TileHeight*16-imprecision; i+=8)
        {
            if(!CanMovePixel(x2, y+i, flags))
                return false;
        }
        
        if(!CanMovePixel(x2, y+16*this->TileHeight-1-imprecision, flags))
            return false;
        
        return true;
    }
    else if(dir==DIR_RIGHT)
    {
        if((Screen->Flags[SF_ROOMTYPE]&010b)!=0 && this->X+16*this->TileWidth+step>=224)
            return false;
        else if(this->X+16*this->TileWidth+step>=256)
            return false;
        
        int x2=this->X+16*this->TileWidth+step;
        int flags=ghost->Misc[GHI_FLAGS];
        
        for(int i=imprecision; i<this->TileHeight*16-imprecision; i+=8)
        {
            if(!CanMovePixel(x2, y+i, flags))
                return false;
        }
        
        if(!CanMovePixel(x2, y+16*this->TileHeight-1-imprecision, flags))
            return false;
        
        return true;
    }
    else // Invalid direction
        return false;
}

bool CanMovePixel(int x, int y, int flags)
{
    int combo=ComboAt(x, y);
    
    // "No enemy" flags and combos
    if(Screen->ComboT[combo]==CT_NOENEMY)
        return false;
    if(Screen->ComboF[combo]==CF_NOENEMY)
        return false;
    if(Screen->ComboI[combo]==CF_NOENEMY)
        return false;
    
    // Water and pit walkability override solidity checking
    if(IsWater(combo))
    {
        if((flags&GHF_IGNORE_WATER)==0)
            return false;
    }
    else if(IsPit(combo))
    {
        if((flags&GHF_IGNORE_PITS)==0)
            return false;
    }
    else if(Screen->isSolid(x, y))
    {
        if((flags&GHF_IGNORE_SOLIDITY)==0)
            return false;
    }
    
    return true;
}

void Move(ffc this, npc ghost, float xStep, float yStep, int imprecision)
{
    if((ghost->Misc[GHI_FLAGS]&GHF_SET_DIRECTION)!=0)
    {
        // Figure out the base combo, in case GHF_4WAY is set
        int baseCombo=this->Data-ghost->Dir;
        
        if(Abs(yStep)>Abs(xStep))
        {
            if(yStep<0)
                ghost->Dir=DIR_UP;
            else
                ghost->Dir=DIR_DOWN;
        }
        else
        {
            if(xStep<0)
                ghost->Dir=DIR_LEFT;
            else
                ghost->Dir=DIR_RIGHT;
        }
        
        if((ghost->Misc[GHI_FLAGS]&GHF_4WAY)!=0)
            this->Data=baseCombo+ghost->Dir;
    }

    if(yStep<0)
    {
        if(CanMove(this, ghost, DIR_UP, -yStep, imprecision))
        {
            this->Y+=yStep;
            ghost->Y+=yStep;
        }
    }
    else if(yStep>0)
    {
        if(CanMove(this, ghost, DIR_DOWN, yStep, imprecision))
        {
            this->Y+=yStep;
            ghost->Y+=yStep;
        }
    }
    if(xStep<0)
    {
        if(CanMove(this, ghost, DIR_LEFT, -xStep, imprecision))
        {
            this->X+=xStep;
            ghost->X+=xStep;
        }
    }
    else if(xStep>0)
    {
        if(CanMove(this, ghost, DIR_RIGHT, xStep, imprecision))
        {
            this->X+=xStep;
            ghost->X+=xStep;
        }
    }
}

void MoveAtAngle(ffc this, npc ghost, float angle, float step, int imprecision)
{
    Move(this, ghost, VectorX(step, angle), VectorY(step, angle), imprecision);
}

void MoveTowardLink(ffc this, npc ghost, float step, int imprecision)
{
    float angle=Angle(this->X, this->Y, Link->X, Link->Y);
    Move(this, ghost, VectorX(step, angle), VectorY(step, angle), imprecision);
}

void Transform(ffc this, npc ghost, int combo, int cset, int tileWidth, int tileHeight)
{
    int diff;
    
    if(combo>=0)
        this->Data=combo;

    if(cset>=0)
    {
        this->CSet=cset;
        ghost->CSet=cset;
    }
    
    if(tileWidth>0)
    {
        diff=8*(this->TileWidth-tileWidth);
        this->X=this->X+diff;
        ghost->TileWidth=this->TileWidth;
        this->TileWidth=tileWidth;
        ghost->X=ghost->X+diff;
    }
    
    if(tileHeight>0)
    {
        diff=8*(this->TileHeight-tileHeight);
        this->Y=this->Y+diff;
        ghost->TileHeight=this->TileHeight;
        this->TileHeight=tileHeight;
        ghost->Y=ghost->Y+diff;
    }
    
    SetOffsets(this, ghost, 0, 0, 0, 0);
}

void SwapGhost(npc oldGhost, npc newGhost, bool copyHP)
{
    newGhost->X=oldGhost->X;
    newGhost->Y=oldGhost->Y;
    newGhost->Z=oldGhost->Z;
    newGhost->Jump=oldGhost->Jump;
    newGhost->Dir=oldGhost->Dir;
    
    newGhost->Extend=oldGhost->Extend;
    newGhost->TileWidth=oldGhost->TileWidth;
    newGhost->TileHeight=oldGhost->TileHeight;
    newGhost->HitWidth=oldGhost->HitWidth;
    newGhost->HitHeight=oldGhost->HitHeight;
    newGhost->HitXOffset=oldGhost->HitXOffset;
    newGhost->HitYOffset=oldGhost->HitYOffset;
    newGhost->CSet=oldGhost->CSet;
    newGhost->CollDetection=oldGhost->CollDetection;
    
    for(int i=0; i<16; i++)
        newGhost->Misc[i]=oldGhost->Misc[i];
    
    if(copyHP)
        newGhost->HP=oldGhost->HP;
    
    // Move the old ghost out of the way
    oldGhost->CollDetection=false;
    oldGhost->X=256;
    oldGhost->X=176;
}

void ReplaceGhost(npc oldGhost, npc newGhost, bool copyHP)
{
    SwapGhost(oldGhost, newGhost, copyHP);
    
    oldGhost->X=384;
    oldGhost->HP=-1000;
}

void SetOffsets(ffc this, npc ghost, float top, float bottom, float left, float right)
{
    if(top>0 && top<1)
        top=Round(top*this->TileHeight*16);
    if(bottom>0 && bottom<1)
        bottom=Round(bottom*this->TileHeight*16);
    if(left>0 && left<1)
        left=Round(left*this->TileWidth*16);
    if(right>0 && right<1)
        right=Round(right*this->TileWidth*16);
    
    ghost->HitXOffset=left;
    ghost->HitYOffset=top;
    ghost->HitWidth=16*this->TileWidth-(left+right);
    ghost->HitHeight=16*this->TileHeight-(top+bottom);
}

void Set4WayCombo(ffc this, npc ghost, int newCombo)
{
    this->Data=newCombo+ghost->Dir;
}

void SetHP(ffc this, npc ghost, int newHP)
{
    ghost->HP=newHP;
    ghost->Misc[GHI_PREV_HP]=newHP;
}

void SetAllDefenses(npc ghost, int defType)
{
    for(int i=0; i<17; i++)
        ghost->Defense[i]=defType;
}

void SetCSet(ffc this, npc ghost, int newCSet)
{
    // Don't change the FFC's color if it's not already the normal one
    if(this->CSet==ghost->CSet)
    {
        ghost->CSet=newCSet;
        this->CSet=ghost->CSet;
    }
    else
        ghost->CSet=newCSet;
}

void RevertCSet(ffc this, npc ghost)
{
    this->CSet=ghost->CSet;
}

bool GotHit(npc ghost)
{
    return (ghost->Misc[GHI_FLAGS]&GHF_GOT_HIT)!=0;
}

npc SpawnNPC(int id)
{
    int tileRatings[176];
    int checkCombo;
    int bestRating;
    int bestCount;
    int counter;
    int choice;
    int tries;
    
    npc checkNPC;
    npc theNPC;
    
    // First, rate each tile for suitability. Lower is better, but negative means it's strictly off-limits.
    
    // Tiles used by or next to other NPCs are undesirable
    for(int i=Screen->NumNPCs(); i>0; i--)
    {
        checkNPC=Screen->LoadNPC(i);
        checkCombo=ComboAt(checkNPC->X, checkNPC->Y);
        tileRatings[checkCombo]+=100;
        
        if(checkCombo>15)
            tileRatings[checkCombo-16]+=1;
        if(checkCombo<160)
            tileRatings[checkCombo+16]+=1;
        if(checkCombo%16>0)
            tileRatings[checkCombo-1]+=1;
        if(checkCombo%16<15)
            tileRatings[checkCombo+1]+=1;
    }
    
    // Mark other prohibited tiles
    for(int i=0; i<176; i++)
    {
        // Screen edges in NES dungeon
        if((Screen->Flags[SF_ROOMTYPE]&010b)!=0 && (i<32 || i>143 || i%16<2 || i%16>13))
            tileRatings[i]=-1;
        // "No enemy" flag and combos
        else if(Screen->ComboF[i]==CF_NOENEMY || Screen->ComboI[i]==CF_NOENEMY ||
                Screen->ComboT[i]==CT_NOENEMY || Screen->ComboT[i]==CT_NOFLYZONE ||
                Screen->ComboT[i]==CT_NOJUMPZONE)
            tileRatings[i]=-1;
        // Water and pits
        else if(IsWater(i) || IsPit(i))
            tileRatings[i]=-1;
        // Solid combos
        else if(Screen->ComboS[i]!=0)
            tileRatings[i]=-1;
    }
    
    // Find the best rating and count the number of tiles with that rating
    bestRating=10000;
    bestCount=0;
    for(int i=0; i<176; i++)
    {
        if(tileRatings[i]<0)
            continue;
        
        if(tileRatings[i]==bestRating)
            bestCount++;
        else if(tileRatings[i]<bestRating)
        {
            bestRating=tileRatings[i];
            bestCount=1;
        }
    }
    
    // Pick at random from the best rated tiles, but pick again if it's too close to Link
    do {
        counter=Rand(bestCount)+1;
        for(choice=0; counter>0; choice++)
        {
            if(tileRatings[choice]==bestRating)
                counter--;
        }
        
        // Limit the number of tries to ensure this doesn't become an infinite loop
        tries++;
    } while(Distance(ComboX(choice), ComboY(choice), Link->X, Link->Y)<40 && tries<256)

    
    theNPC=Screen->CreateNPC(id);
    theNPC->X=ComboX(choice-1);
    theNPC->Y=ComboY(choice-1);
    return theNPC;
}


// =================
// |||| EWEAPON ||||
// =================

eweapon FireEWeapon(int weaponID, int x, int y, float angle, int step, int damage, int sprite, int sound, int flags)
{
    eweapon wpn=Screen->CreateEWeapon(weaponID);
    wpn->X=x;
    wpn->Y=y;
    wpn->Step=step;
    wpn->Damage=damage;
    wpn->Angular=true;
    wpn->Angle=angle;
    SetEWeaponDir(wpn);
    
    if(sprite>=0)
        wpn->UseSprite(sprite);
    
    wpn->Misc[EWI_FLAGS]=flags|EWF_IS_GHZH_EWPN;
    
    if((wpn->Misc[EWI_FLAGS]&EWF_ROTATE)!=0)
        SetEWeaponRotation(wpn);
    
    Game->PlaySound(sound);
    
    return wpn;
}

eweapon FireAimedEWeapon(int weaponID, int x, int y, float angle, int step, int damage, int sprite, int sound, int flags)
{
    return FireEWeapon(weaponID, x, y, ArcTan(Link->X-x, Link->Y-y)+angle, step, damage, sprite, sound, flags);
}

eweapon FireNonAngularEWeapon(int weaponID, int x, int y, int direction, int step, int damage, int sprite, int sound, int flags)
{
    eweapon wpn=Screen->CreateEWeapon(weaponID);
    wpn->X=x;
    wpn->Y=y;
    wpn->Dir=direction;
    wpn->Step=step;
    wpn->Damage=damage;
    if(sprite>=0)
        wpn->UseSprite(sprite);
    
    wpn->Misc[EWI_FLAGS]=flags|EWF_IS_GHZH_EWPN;
    
    if((wpn->Misc[EWI_FLAGS]&EWF_ROTATE)!=0)
        SetEWeaponRotation(wpn);
    
    Game->PlaySound(sound);
    return wpn;
}

eweapon FireBigEWeapon(int weaponID, int x, int y, float angle, int step, int damage, int sprite, int sound, int flags, int width, int height)
{
    eweapon wpn=FireEWeapon(weaponID, x, y, angle, step, damage, sprite, sound, flags);
    wpn->Extend=3;
    wpn->TileWidth=width;
    wpn->TileHeight=height;
    wpn->HitWidth=16*width;
    wpn->HitHeight=16*height;
    return wpn;
}

eweapon FireBigAimedEWeapon(int weaponID, int x, int y, float angle, int step, int damage, int sprite, int sound, int flags, int width, int height)
{
    eweapon wpn=FireEWeapon(weaponID, x, y, ArcTan(Link->X-x, Link->Y-y)+angle, step, damage, sprite, sound, flags);
    wpn->Extend=3;
    wpn->TileWidth=width;
    wpn->TileHeight=height;
    wpn->HitWidth=16*width;
    wpn->HitHeight=16*height;
    return wpn;
}

eweapon FireBigNonAngularEWeapon(int weaponID, int x, int y, int direction, int step, int damage, int sprite, int sound, int flags, int width, int height)
{
    eweapon wpn=FireNonAngularEWeapon(weaponID, x, y, direction, step, damage, sprite, sound, flags);
    wpn->Extend=3;
    wpn->TileWidth=width;
    wpn->TileHeight=height;
    wpn->HitWidth=16*width;
    wpn->HitHeight=16*height;
    return wpn;
}

void SetEWeaponMovement(eweapon wpn, int type, int arg)
{
    wpn->Misc[EWI_XPOS]=wpn->X;
    wpn->Misc[EWI_YPOS]=wpn->Y;
    wpn->Misc[EWI_WORK]=0;
    wpn->Misc[EWI_MOVEMENT]=type;
    wpn->Misc[EWI_MOVEMENT_ARG]=arg;
    if(type==EWM_HOMING_REAIM || type==EWM_RANDOM_REAIM)
        wpn->Misc[EWI_WORK_2]=wpn->Step;
    else if(type==EWM_THROW)
    {
        wpn->Misc[EWI_WORK_2]=wpn->Z;
        
        // Necessary upward velocity to reach Link for thrown weapons.
        // A rough approximation, but it should be close enough.
        if(arg<=0)
        {
            float time=Distance(wpn->X, wpn->Y, Link->X, Link->Y)/(wpn->Step/100);
            wpn->Misc[EWI_MOVEMENT_ARG]=GH_GRAVITY*time/2;
        }
    }
    else if(type==EWM_FALL)
    {
        wpn->Z=arg;
        wpn->Misc[EWI_WORK]=GH_GRAVITY;
    }
}

void SetEWeaponLifespan(eweapon wpn, int type, int arg)
{
    wpn->Misc[EWI_LIFESPAN]=type;
    wpn->Misc[EWI_LIFESPAN_ARG]=arg;
}

void SetEWeaponDeathEffect(eweapon wpn, int type, int arg)
{
    // These really weren't necessary in the first place, were they?
    if(type==EWD_4_FIREBALLS_RANDOM)
    {
        if(Rand(2)==0)
            type=EWD_4_FIREBALLS_HV;
        else
            type=EWD_4_FIREBALLS_DIAG;
    }
    else if(type==EWD_4_FIRES_RANDOM)
    {
        if(Rand(2)==0)
            type=EWD_4_FIRES_HV;
        else
            type=EWD_4_FIRES_DIAG;
    }
    
    wpn->Misc[EWI_ON_DEATH]=type;
    wpn->Misc[EWI_ON_DEATH_ARG]=arg;
}

void UpdateEWeapon(eweapon wpn)
{
    // Not a ghost.zh-spawned weapon? Don't do anything
    if((wpn->Misc[EWI_FLAGS]&EWF_IS_GHZH_EWPN)==0)
        return;
    
    if((wpn->Misc[EWI_FLAGS]&EWF_UNBLOCKABLE)!=0)
    {
        // A weapon is made unblockable by setting its direction to match Link's each frame.
        wpn->Dir=Link->Dir;
        if((wpn->Misc[EWI_FLAGS]&EWF_ROTATE)!=0)
            SetEWeaponRotation(wpn);
    }
    
    // Weapons can't be made invisible; use DrawXOffset instead
    if((wpn->Misc[EWI_FLAGS]&EWF_FLICKER)!=0)
    {
        if(wpn->DrawXOffset<10000)
            wpn->DrawXOffset+=10000;
        else
            wpn->DrawXOffset-=10000;
    }
    
    if((wpn->Misc[EWI_FLAGS]&EWF_SHADOW)!=0)
        DrawEWeaponShadow(wpn);
    
    // Is the movement pattern still active?
    if((wpn->Misc[EWI_FLAGS]&EWF_DEAD)==0)
    {
        if(wpn->Misc[EWI_MOVEMENT]!=0)
        {
            // Split in half to reduce checks
            if(wpn->Misc[EWI_MOVEMENT]<7)
            {
                // Sine waves
                if(wpn->Misc[EWI_MOVEMENT]==EWM_SINE_WAVE)
                {
                    // For sine waves, adjust the weapon's position at an angle
                    // perpendicular to that of its natural movement.
                    float offset;
                    wpn->Misc[EWI_WORK]+=15;
                    offset=wpn->Misc[EWI_MOVEMENT_ARG]*Sin(wpn->Misc[EWI_WORK]);
                    wpn->Misc[EWI_XPOS]+=(wpn->Step/100)*RadianCos(wpn->Angle);
                    wpn->Misc[EWI_YPOS]+=(wpn->Step/100)*RadianSin(wpn->Angle);
                    wpn->X=wpn->Misc[EWI_XPOS]+offset*RadianCos(wpn->Angle+1.5708);
                    wpn->Y=wpn->Misc[EWI_YPOS]+offset*RadianSin(wpn->Angle+1.5708);
                }
                
                else if(wpn->Misc[EWI_MOVEMENT]==EWM_SINE_WAVE_FAST)
                {
                    float offset;
                    wpn->Misc[EWI_WORK]+=36;
                    offset=wpn->Misc[EWI_MOVEMENT_ARG]*Sin(wpn->Misc[EWI_WORK]);
                    wpn->Misc[EWI_XPOS]+=(wpn->Step/100)*RadianCos(wpn->Angle);
                    wpn->Misc[EWI_YPOS]+=(wpn->Step/100)*RadianSin(wpn->Angle);
                    wpn->X=wpn->Misc[EWI_XPOS]+offset*RadianCos(wpn->Angle+1.5708);
                    wpn->Y=wpn->Misc[EWI_YPOS]+offset*RadianSin(wpn->Angle+1.5708);
                }
                
                // Homing
                else if(wpn->Misc[EWI_MOVEMENT]==EWM_HOMING)
                {
                    float angle1=wpn->Angle%6.2832;    
                    if(angle1<0)
                        angle1+=6.2832;
                    
                    float angle2=RadianAngle(wpn->X, wpn->Y, Link->X, Link->Y);
                    if(angle2<0)
                        angle2+=6.2832;
                    
                    float diff=Abs(angle1-angle2);
                    
                    if(diff<wpn->Misc[EWI_MOVEMENT_ARG] || diff>6.2832-wpn->Misc[EWI_MOVEMENT_ARG])
                        wpn->Angle=angle2;
                    else if(Sign(angle1-angle2)==Sign(diff-PI)) // if angle1>angle2 and diff>pi or angle1<angle2 and diff<pi
                        wpn->Angle+=wpn->Misc[EWI_MOVEMENT_ARG];
                    else
                        wpn->Angle-=wpn->Misc[EWI_MOVEMENT_ARG];
                }
                
                else if(wpn->Misc[EWI_MOVEMENT]==EWM_HOMING_REAIM)
                {
                    if(wpn->Misc[EWI_WORK]==0)
                        wpn->Misc[EWI_WORK]=45;

                    if(wpn->Misc[EWI_WORK]>0) // If positive, wpn is moving
                    {
                        wpn->Misc[EWI_WORK]--;
                        if(wpn->Misc[EWI_WORK]==0)
                        {
                            if(wpn->Misc[EWI_MOVEMENT_ARG]<=0) // No more aims left
                                KillEWeapon(wpn);
                            else // Stop
                            {
                                wpn->Misc[EWI_MOVEMENT_ARG]--;
                                wpn->Step=0;
                                wpn->Misc[EWI_WORK]=-20;
                            }
                        }
                    }
                    else // If negative, it's stopped to aim
                    {
                        wpn->Misc[EWI_WORK]++;
                        if(wpn->Misc[EWI_WORK]==0) // Start up again
                        {
                            wpn->Misc[EWI_WORK]=45;
                            wpn->Angle=RadianAngle(wpn->X, wpn->Y, Link->X, Link->Y);
                            wpn->Step=wpn->Misc[EWI_WORK_2];
                            SetEWeaponDir(wpn);
                            if((wpn->Misc[EWI_FLAGS]&EWF_ROTATE)!=0)
                                SetEWeaponRotation(wpn);
                        }
                        // Spin while waiting
                        else if((wpn->Misc[EWI_FLAGS]&EWF_ROTATE)!=0)
                        {
                            int dir=-wpn->Misc[EWI_WORK]&110b;
                            if(dir==110b)
                                SetEWeaponRotation(wpn, DIR_UP);
                            else if(dir==100b)
                                SetEWeaponRotation(wpn, DIR_RIGHT);
                            else if(dir==010b)
                                SetEWeaponRotation(wpn, DIR_DOWN);
                            else
                                SetEWeaponRotation(wpn, DIR_LEFT);
                        }
                    }
                }
                
                // Random
                else if(wpn->Misc[EWI_MOVEMENT]==EWM_RANDOM)
                {
                    wpn->Angle+=Randf(2*wpn->Misc[EWI_MOVEMENT_ARG])-wpn->Misc[EWI_MOVEMENT_ARG]; // Randf(-arg, arg) doesn't work right...?
                    SetEWeaponDir(wpn);
                    if((wpn->Misc[EWI_FLAGS]&EWF_ROTATE)!=0)
                        SetEWeaponRotation(wpn);
                }
                
                else if(wpn->Misc[EWI_MOVEMENT]==EWM_RANDOM_REAIM) // Almost the same as homing re-aim
                {
                    if(wpn->Misc[EWI_WORK]==0)
                        wpn->Misc[EWI_WORK]=45;

                    if(wpn->Misc[EWI_WORK]>0) // If positive, wpn is moving
                    {
                        wpn->Misc[EWI_WORK]--;
                        if(wpn->Misc[EWI_WORK]==0)
                        {
                            if(wpn->Misc[EWI_MOVEMENT_ARG]<=0) // No more aims left
                                KillEWeapon(wpn);
                            else // Stop
                            {
                                wpn->Misc[EWI_MOVEMENT_ARG]--;
                                wpn->Step=0;
                                wpn->Misc[EWI_WORK]=-20;
                            }
                        }

                    }
                    else // If negative, it's stopped to aim
                    {
                        wpn->Misc[EWI_WORK]++;
                        if(wpn->Misc[EWI_WORK]==0) // Start up again
                        {
                            wpn->Misc[EWI_WORK]=45;
                            wpn->Angle=Rand(31416)/5000;
                            wpn->Step=wpn->Misc[EWI_WORK_2];
                            SetEWeaponDir(wpn);
                            if((wpn->Misc[EWI_FLAGS]&EWF_ROTATE)!=0)
                                SetEWeaponRotation(wpn);
                        }
                        // Spin while waiting
                        else if((wpn->Misc[EWI_FLAGS]&EWF_ROTATE)!=0)
                        {
                            int dir=-wpn->Misc[EWI_WORK]&110b;

                            if(dir==110b)
                                SetEWeaponRotation(wpn, DIR_UP);
                            else if(dir==100b)
                                SetEWeaponRotation(wpn, DIR_RIGHT);
                            else if(dir==010b)
                                SetEWeaponRotation(wpn, DIR_DOWN);
                            else
                                SetEWeaponRotation(wpn, DIR_LEFT);
                        }
                    }
                }
            }
            else // wpn->Misc[EWI_MOVEMENT]>=7
            {
                // Veering
                if(wpn->Misc[EWI_MOVEMENT]==EWM_VEER_UP)
                {
                    wpn->Y-=wpn->Misc[EWI_WORK];
                    wpn->Misc[EWI_WORK]+=wpn->Misc[EWI_MOVEMENT_ARG];
                }
                
                else if(wpn->Misc[EWI_MOVEMENT]==EWM_VEER_DOWN)
                {
                    wpn->Y+=wpn->Misc[EWI_WORK];
                    wpn->Misc[EWI_WORK]+=wpn->Misc[EWI_MOVEMENT_ARG];
                }
                
                else if(wpn->Misc[EWI_MOVEMENT]==EWM_VEER_LEFT)
                {
                    wpn->X-=wpn->Misc[EWI_WORK];
                    wpn->Misc[EWI_WORK]+=wpn->Misc[EWI_MOVEMENT_ARG];
                }
                
                else if(wpn->Misc[EWI_MOVEMENT]==EWM_VEER_RIGHT)
                {
                    wpn->X+=wpn->Misc[EWI_WORK];
                    wpn->Misc[EWI_WORK]+=wpn->Misc[EWI_MOVEMENT_ARG];
                }
                
                // Throw
                else if(wpn->Misc[EWI_MOVEMENT]==EWM_THROW)
                {
                    wpn->Jump=0; // Override engine handling of Z movement
                    if(wpn->Misc[EWI_WORK]==0 && wpn->Misc[EWI_MOVEMENT_ARG]!=0)
                    {
                        wpn->Misc[EWI_WORK]=wpn->Misc[EWI_MOVEMENT_ARG];
                        wpn->Misc[EWI_MOVEMENT_ARG]=0;
                    }
                    
                    wpn->Misc[EWI_WORK_2]=Max(wpn->Misc[EWI_WORK_2]+wpn->Misc[EWI_WORK], wpn->Misc[EWI_WORK_2]-GH_TERMINAL_VELOCITY);
                    wpn->Z=wpn->Misc[EWI_WORK_2];
                    if(wpn->Misc[EWI_WORK_2]<=0)
                        KillEWeapon(wpn);
                    else
                        wpn->Misc[EWI_WORK]-=GH_GRAVITY;
                }
                
                // Fall
                else if(wpn->Misc[EWI_MOVEMENT]==EWM_FALL)
                {
                    wpn->Jump=0; // Override engine handling of Z movement
                    wpn->Z-=wpn->Misc[EWI_WORK]; 
                    wpn->Misc[EWI_WORK]=Min(wpn->Misc[EWI_WORK]+GH_GRAVITY, GH_TERMINAL_VELOCITY);
                    
                    if(wpn->Z+wpn->Jump<=0)
                    {
                        wpn->Z=0;
                        KillEWeapon(wpn);
                    }
                }
            }
        }
        
        if(wpn->Misc[EWI_LIFESPAN]!=0)
        {
            if(wpn->Misc[EWI_LIFESPAN]==EWL_TIMER)
            {
                wpn->Misc[EWI_LIFESPAN_ARG]-=1;
                if(wpn->Misc[EWI_LIFESPAN_ARG]<=0)
                    KillEWeapon(wpn);
            }
            else if(wpn->Misc[EWI_LIFESPAN]==EWL_NEAR_LINK)
            {
                if(Distance(wpn->X, wpn->Y, Link->X, Link->Y)<wpn->Misc[EWI_LIFESPAN_ARG])
                    KillEWeapon(wpn);
            }
            else if(wpn->Misc[EWI_LIFESPAN]==EWL_SLOW_TO_HALT)
            {
                wpn->Step=Max(0, wpn->Step-wpn->Misc[EWI_LIFESPAN_ARG]);
                if(wpn->Step<=0)
                    KillEWeapon(wpn);
            }
        }
    }
    
    // Dead?
    else
    {
        // Split in half to reduce checks
        if(wpn->Misc[EWI_ON_DEATH]<8)
        {
            if(wpn->Misc[EWI_ON_DEATH]==EWD_VANISH)
                wpn->DeadState=0;
            else if(wpn->Misc[EWI_ON_DEATH]==EWD_AIM_AT_LINK)
            {
                wpn->Step=0;
                wpn->Misc[EWI_ON_DEATH_ARG]-=1;
                if(wpn->Misc[EWI_ON_DEATH_ARG]<=0)
                {
                    wpn->Angle=RadianAngle(wpn->X, wpn->Y, Link->X, Link->Y);
                    SetEWeaponDir(wpn);
                    SetEWeaponRotation(wpn);
                    wpn->Step=300;
                    wpn->Misc[EWI_ON_DEATH]=0;
                }
                // Spin while waiting
                else if((wpn->Misc[EWI_FLAGS]&EWF_ROTATE)!=0)
                {
                    int dir=wpn->Misc[EWI_ON_DEATH_ARG]&110b;
                    if(dir==110b)
                        SetEWeaponRotation(wpn, DIR_UP);
                    else if(dir==100b)
                        SetEWeaponRotation(wpn, DIR_RIGHT);
                    else if(dir==010b)
                        SetEWeaponRotation(wpn, DIR_DOWN);
                    else
                        SetEWeaponRotation(wpn, DIR_LEFT);
                }
            }
            else if(wpn->Misc[EWI_ON_DEATH]==EWD_EXPLODE)
            {
                FireNonAngularEWeapon(EW_BOMBBLAST, CenterX(wpn)-8, CenterY(wpn)-8, wpn->Dir, 0, wpn->Misc[EWI_ON_DEATH_ARG], -1, false, 0);
                wpn->DeadState=0;
            }
            else if(wpn->Misc[EWI_ON_DEATH]==EWD_SBOMB_EXPLODE)
            {
                FireNonAngularEWeapon(EW_SBOMBBLAST, CenterX(wpn)-8, CenterY(wpn)-8, wpn->Dir, 0, wpn->Misc[EWI_ON_DEATH_ARG], -1, false, 0);
                wpn->DeadState=0;
            }
            else if(wpn->Misc[EWI_ON_DEATH]==EWD_4_FIREBALLS_HV)
            {
                for(int i=0; i<4; i++)
                    FireNonAngularEWeapon(EW_FIREBALL, CenterX(wpn)-8, CenterY(wpn)-8, i, 200, wpn->Damage/2, wpn->Misc[EWI_ON_DEATH_ARG], false, 0);
                wpn->DeadState=0;
            }
            else if(wpn->Misc[EWI_ON_DEATH]==EWD_4_FIREBALLS_DIAG)
            {
                for(int i=4; i<8; i++)
                    FireNonAngularEWeapon(EW_FIREBALL, CenterX(wpn)-8, CenterY(wpn)-8, i, 200, wpn->Damage/2, wpn->Misc[EWI_ON_DEATH_ARG], false, 0);
                wpn->DeadState=0;
            }
        }
        else
        {
            if(wpn->Misc[EWI_ON_DEATH]==EWD_8_FIREBALLS)
            {
                for(int i=0; i<8; i++)
                    FireNonAngularEWeapon(EW_FIREBALL, CenterX(wpn)-8, CenterY(wpn)-8, i, 200, wpn->Damage/2, wpn->Misc[EWI_ON_DEATH_ARG], false, 0);
                wpn->DeadState=0;
            }
            else if(wpn->Misc[EWI_ON_DEATH]==EWD_4_FIRES_HV)
            {
                for(int i=0; i<4; i++)
                    FireNonAngularEWeapon(EW_FIRE, CenterX(wpn)-8, CenterY(wpn)-8, i, 100, wpn->Damage/2, wpn->Misc[EWI_ON_DEATH_ARG], false, 0);
                Game->PlaySound(SFX_FIRE); // Only play sound once
                wpn->DeadState=0;
            }
            else if(wpn->Misc[EWI_ON_DEATH]==EWD_4_FIRES_DIAG)
            {
                for(int i=4; i<8; i++)
                    FireNonAngularEWeapon(EW_FIRE, CenterX(wpn)-8, CenterY(wpn)-8, i, 71, wpn->Damage/2, wpn->Misc[EWI_ON_DEATH_ARG], false, 0);
                Game->PlaySound(SFX_FIRE);
                wpn->DeadState=0;
            }
            else if(wpn->Misc[EWI_ON_DEATH]==EWD_8_FIRES)
            {
                for(int i=0; i<4; i++)
                    FireNonAngularEWeapon(EW_FIRE, CenterX(wpn)-8, CenterY(wpn)-8, i, 100, wpn->Damage/2, wpn->Misc[EWI_ON_DEATH_ARG], false, 0);
                for(int i=4; i<8; i++)
                    FireNonAngularEWeapon(EW_FIRE, CenterX(wpn)-8, CenterY(wpn)-8, i, 71, wpn->Damage/2, wpn->Misc[EWI_ON_DEATH_ARG], false, 0);
                Game->PlaySound(SFX_FIRE);
                wpn->DeadState=0;
            }
            else if(wpn->Misc[EWI_ON_DEATH]==EWD_SPAWN_NPC)
            {
                npc enemy=Screen->CreateNPC(wpn->Misc[EWI_ON_DEATH_ARG]);
                enemy->X=wpn->X;
                enemy->Y=wpn->Y;
                wpn->DeadState=0;
            }
        }
    }
}

void UpdateEWeapons()
{
    eweapon wpn;
    
    for(int i=Screen->NumEWeapons(); i>0; i--)
    {
        wpn=Screen->LoadEWeapon(i);
        UpdateEWeapon(wpn);
    }
}

void SetEWeaponDir(eweapon wpn)
{
    float angle=wpn->Angle%6.2832;    
    if(angle<0)
        angle+=6.2832;
        
    if(angle<0.3927 || angle>5.8905)
        wpn->Dir=DIR_RIGHT;
    else if(angle<1.1781)
        wpn->Dir=DIR_RIGHTDOWN;
    else if(angle<1.9635)
        wpn->Dir=DIR_DOWN;
    else if(angle<2.7489)
        wpn->Dir=DIR_LEFTDOWN;
    else if(angle<3.5343)
        wpn->Dir=DIR_LEFT;
    else if(angle<4.3197)
        wpn->Dir=DIR_LEFTUP;
    else if(angle<5.1051)
        wpn->Dir=DIR_UP;
    else
        wpn->Dir=DIR_RIGHTUP;
}


void SetEWeaponRotation(eweapon wpn)
{
    if(wpn->Angular)
    {
        float angle=wpn->Angle%6.2832;    
        if(angle<0)
            angle+=6.2832;
            
        if(angle<0.7854 || angle>5.4978) // Right
            wpn->Flip=4;
        else if(angle<=2.3562) // Down
            wpn->Flip=3;
        else if(angle<3.927) // Left
            wpn->Flip=7;
        else // Up
            wpn->Flip=0;
    }
    else
    {
        if(wpn->Dir==DIR_UP || wpn->Dir==DIR_RIGHTUP || wpn->Dir==DIR_LEFTUP)
            wpn->Flip=0;
        else if(wpn->Dir==DIR_DOWN || wpn->Dir==DIR_RIGHTDOWN || wpn->Dir==DIR_LEFTDOWN)
            wpn->Flip=3;
        else if(wpn->Dir==DIR_LEFT)
            wpn->Flip=7;
        else // Right
            wpn->Flip=4;
    }
}

void SetEWeaponRotation(eweapon wpn, int direction)
{
    if(direction==DIR_UP || direction==DIR_RIGHTUP || direction==DIR_LEFTUP)
        wpn->Flip=0;
    else if(direction==DIR_DOWN || direction==DIR_RIGHTDOWN || direction==DIR_LEFTDOWN)
        wpn->Flip=3;
    else if(direction==DIR_LEFT)
        wpn->Flip=7;
    else // Right
        wpn->Flip=4;
}

void KillEWeapon(eweapon wpn)
{
    wpn->Misc[EWI_FLAGS]|=EWF_DEAD;
}

void DrawEWeaponShadow(eweapon wpn)
{
    int x=CenterX(wpn)-8+wpn->DrawXOffset;
    int y=wpn->Y+(wpn->TileHeight-1)*16+wpn->DrawYOffset;
    
    if(GH_SHADOW_TRANSLUCENT>0)
        Screen->DrawTile(3, x, y, GH_SHADOW_TILE, 1, 1, GH_SHADOW_CSET, -1, -1, 0, 0, 0, 0, true, 64);
    else
        Screen->DrawTile(3, x, y, GH_SHADOW_TILE, 1, 1, GH_SHADOW_CSET, -1, -1, 0, 0, 0, 0, true, 128);
}


// =================================
// |||| DEPRECATED - DO NOT USE ||||
// =================================

eweapon FireEWeapon(int weaponID, int x, int y, float angle, int step, int damage, bool blockable, int sprite, bool rotate, int sound)
{
    int flags=0;
    if(!blockable)
        flags|=EWF_UNBLOCKABLE;
    if(rotate)
        flags|=EWF_ROTATE;
    return FireEWeapon(weaponID, x, y, angle, step, damage, sprite, sound, flags);
}

eweapon FireAimedEWeapon(int weaponID, int x, int y, float angle, int step, int damage, bool blockable, int sprite, bool rotate, int sound)
{
    int flags=0;
    if(!blockable)
        flags|=EWF_UNBLOCKABLE;
    if(rotate)
        flags|=EWF_ROTATE;
    return FireEWeapon(weaponID, x, y, ArcTan(Link->X-x, Link->Y-y)+angle, step, damage, sprite, sound, flags);
}

eweapon FireNonAngularEWeapon(int weaponID, int x, int y, int direction, int step, int damage, int sprite, bool rotate, int sound)
{
    int flags=0;
    if(rotate)
        flags|=EWF_ROTATE;
    return FireNonAngularEWeapon(weaponID, x, y, direction, step, damage, sprite, sound, flags);
}

void SetFlags(ffc this, int flags)
{
    SetFlags(this, Screen->LoadNPC(1), flags);
}

npc GhostInitWait2(ffc this, int enemyID, int which, bool useEnemyPos)
{
    return GhostInitWait2(this, enemyID, useEnemyPos);
}

npc GhostInitWait2(ffc this, int enemyID, int which, bool useEnemyPos, int flags)
{
    return GhostInitWait2(this, enemyID, useEnemyPos, flags);
}
