// ghost.zh
// Version 3.0.0 - Alpha 5

namespace ghost3
{
	
	const int GH_VX = 26;
	const int GH_VY = 27;
	const int GH_AX = 28;
	const int GH_AY = 29;
	const int GH_DATA = 30;
	const int GH_INTERNAL = 31;

	int GetInternal(npc ghost, int index)
	{
		int flags = ghost->Misc[GH_INTERNAL];
		return flags[index];
	}
	void SetInternal(npc ghost, int index, untyped value)
	{
		int flags = ghost->Misc[GH_INTERNAL];
		flags[index] = value;
	}

	bool Ghost_Waitframe(npc ghost, bool clearOnDeath, bool quitOnDeath)
	{
		// Handle gravity first
		int jump = ghost->Jump;
		ghost->Jump=0;
		unless(FlagIsSet(ghost, GHF_NO_FALL))
		{
			// Sideview: Jump/fall on Y axis
			if(IsSideview())
			{
				// Use CanMove to check for platforms
				if(jump || CanMove(ghost, DIR_DOWN, 1, Game->Ghost[GHV_DEFAULT_IMPRECISION]))
				{
					// Temporarily unset GHF_SET_DIRECTION so that Ghost_Move doesn't
					// change the enemy's direction here
					bool setDir=FlagIsSet(ghost, GHF_SET_DIRECTION);
					ghost3::UnsetFlag(ghost, GHF_SET_DIRECTION);
					
					// Jumping
					if(jump>0)
					{
						// Set GHF_NO_FALL temporarily so CanMove(DIR_UP) can return true
						ghost3::SetFlag(ghost, GHF_NO_FALL);
						
						ghost3::Move(ghost, DIR_UP, jump, Game->Ghost[GHV_DEFAULT_IMPRECISION]);
						jump=Max(jump-Game->Gravity[GR_STRENGTH], -Game->Gravity[GR_TERMINALV]);
						
						// If it's still jumping, check if it can move any farther;
						// if it can't, it's hit something and should begin falling
						if(jump>0 && !CanMove(ghost, DIR_UP, 1, Game->Ghost[GHV_DEFAULT_IMPRECISION]))
							jump=0;
						
						ghost3::UnsetFlag(ghost, GHF_NO_FALL);
					}
					// Falling
					else
					{
						ghost3::Move(ghost, DIR_DOWN, -jump, Game->Ghost[GHV_DEFAULT_IMPRECISION]);
						
						// Can it fall farther?
						if(CanMove(ghost, DIR_DOWN, 1, Game->Ghost[GHV_DEFAULT_IMPRECISION]))
							jump=Max(jump-Game->Gravity[GR_STRENGTH], -Game->Gravity[GR_TERMINALV]);
						// If not, stop falling
						else
							jump=0;
					}
					
					// Restore the flag
					if(setDir)
						ghost3::SetFlag(ghost, GHF_SET_DIRECTION);
				}
			}
			// Top-down: Jump/fall on Z axis
			else
			{
				if(jump || ghost->Z>0)
				{
					if(ghost->Z+jump<=0)
					{
						ghost->Z=0;
						jump=0;
					}
					else
					{
						ghost->Z += jump;
						jump= Max(jump-Game->Gravity[GR_STRENGTH], -Game->Gravity[GR_TERMINALV]);
					}
				}
			}
		}

		// Then velocity and acceleration
		if(ghost->Misc[GH_VX] || ghost->Misc[GH_VY] || ghost->Misc[GH_AX] || ghost->Misc[GH_AY])
		{
			ghost->Misc[GH_VX] += ghost->Misc[GH_AX];
			ghost->Misc[GH_VY] += ghost->Misc[GH_AY];

			ghost3::MoveXY(ghost, ghost->Misc[GH_VX], ghost->Misc[GH_VY], Game->Ghost[GHV_DEFAULT_IMPRECISION]);
			ghost3::ForceDir(ghost, ghost->Dir);
		}

		ghost3::Ghost_WaitframePart1(ghost, false);
		ghost3::Ghost_WaitframeLight(ghost);
		ghost3::ClearIFlags(ghost);
		return ghost3::Ghost_WaitframePart2(ghost, clearOnDeath, quitOnDeath);
	}

	// Before waiting: Update direction, set combo, set overlay flag, draw shadow
	void Ghost_WaitframePart1(npc ghost, bool useNPCDir)
	{
		// Direction forced - set the npc's direction
		if(ghost->Misc[GH_INTERNAL][GHI_IFLAGS]&GHFI_DIR_FORCED)
			ghost->Dir = ghost->Misc[GH_INTERNAL][GHI_DIR];

		// Set direction based on movement
		else if(FlagIsSet(ghost, GHF_SET_DIRECTION) &&
			(ghost->Misc[GH_INTERNAL][GHI_PREVX] != ghost->X || ghost->Misc[GH_INTERNAL][GHI_PREVY] != ghost->Y))
		{	
			float xStep = ghost->X - ghost->Misc[GH_INTERNAL][GHI_PREVX];
			float yStep = ghost->Y - ghost->Misc[GH_INTERNAL][GHI_PREVY];

			// Use 8 directions if 8-way flag is set
			if(FlagIsSet(ghost, GHF_8WAY))
				ghost->Dir = AngleDir8(WrapAngle(ArcTan(xStep, yStep)) * RADIAN);


			// Otherwise, 4 directions
			else
			{
				if(Abs(xStep)>Abs(yStep))
				{
					if(xStep < 0)
						ghost->Dir = DIR_LEFT;
					else
						ghost->Dir = DIR_RIGHT;
				}
				else
				{
					if(yStep < 0)
						ghost->Dir = DIR_UP;
					else
						ghost->Dir = DIR_DOWN;
				}
			}
		}
		ghost3::SetInternal(ghost, GHI_PREVX, ghost->X);
		ghost3::SetInternal(ghost, GHI_PREVY, ghost->Y);
		
		// Set combo
		if(ghost->Misc[GH_DATA] == Game->Ghost[GHV_SETTINGS_COMBO_ID])
		{
			ghost->Tile = Game->ComboTile(ghost->Misc[GH_DATA]);
		}
		else if(ghost->Misc[GH_DATA] > 0)
		{
			if(FlagIsSet(ghost, GHF_8WAY) || FlagIsSet(ghost, GHF_4WAY))
			{
				if(ghost->Tile != Game->ComboTile(ghost->Misc[GH_DATA] + ghost->Dir))
					ghost->Tile = Game->ComboTile(ghost->Misc[GH_DATA] + NormalizeDir(ghost->Dir));
			}
			else
			{
				if(ghost->Tile != Game->ComboTile(ghost->Misc[GH_DATA]))
					ghost->Tile = Game->ComboTile(ghost->Misc[GH_DATA]);
			}
		}
	}

	// After waiting: Check whether the enemy was hit, stunned, or killed
	bool Ghost_WaitframePart2(npc ghost, bool clearOnDeath, bool quitOnDeath)
	{
		// Is it dead?
		bool dead = isDead(ghost);
		
		// Not dead; was it hit, stunned, or frozen?
		unless(dead)
		{
			dead = !ghost3::CheckFreeze(ghost);
		}
		
		// Dead; clean up
		if(dead)
		{
			if(quitOnDeath)
				Quit();

			return false;
		}
		
		return true;
	}

	bool CheckFreeze(npc ghost)
	{
		if((FlagIsSet(ghost,GHF_CLOCK) && ClockIsActive()) ||
		   (FlagIsSet(ghost,GHF_STUN) && ghost->Stun > 0))
		{
			
			ghost3::SetIFlag(ghost, GHFI_WAS_FROZEN);
			
			// Do nothing except get hit until recovered
			while((FlagIsSet(ghost,GHF_CLOCK) && ClockIsActive()) ||
				  (FlagIsSet(ghost,GHF_STUN) && ghost->Stun > 0))
			{
				Ghost_WaitframeLight(ghost);
				
				unless(ghost->isValid())
					return false;
				else if(isDead(ghost))
					return false;
				
				if(ghost->Misc[GH_DATA] > 0)
				{
					if(FlagIsSet(ghost, GHF_8WAY) || FlagIsSet(ghost, GHF_4WAY))
					{
						if(ghost->Tile != Game->ComboTile(ghost->Misc[GH_DATA] + ghost->Dir))
							ghost->Tile = Game->ComboTile(ghost->Misc[GH_DATA] + NormalizeDir(ghost->Dir));
					}
					else
					{
						if(ghost->Tile != Game->ComboTile(ghost->Misc[GH_DATA]))
							ghost->Tile = Game->ComboTile(ghost->Misc[GH_DATA]);
					}
				}
			}
		}
		
		return true;
	}

	void Ghost_WaitframeLight(npc ghost)
	{
		Waitframe(); //yup. This might get expanded later, but I doubt it.
	}

	bool Ghost_Waitframes(npc ghost, bool clearOnDeath, bool quitOnDeath, int numFrames)
	{
		for(; numFrames>0; --numFrames)
		{
			unless(ghost3::Ghost_Waitframe(ghost, clearOnDeath, quitOnDeath))
				return false;
		}
		return true;
	}

	void Ghost_WaitframesLight(npc ghost, int numFrames)
	{
		for(; numFrames>0; --numFrames)
			ghost3::Ghost_WaitframeLight(ghost);
	}

	void Ghost_Waitframe(npc ghost)
	{
		ghost3::Ghost_Waitframe(ghost, true, true);
	}

	void Ghost_Waitframes(npc ghost, int numFrames)
	{
		ghost3::Ghost_Waitframes(ghost, true, true, numFrames);
	}


	bool Ghost_Waitframe(npc ghost, DeathAnim deathAnimation, bool quitOnDeath)
	{
		unless(ghost3::Ghost_Waitframe(ghost, false, false))
		{
			ghost3::DeathAnimation(ghost, deathAnimation, quitOnDeath);
			if(quitOnDeath)
				Quit();
			return false;
		}
		
		return true;
	}
}
